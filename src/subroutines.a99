*********************************************************************
*
* Animation frame
*
animation_frame:
       .proc
       .push r2
       bl   @vsync
       bl   @vsync
       bl   @wally_draw
       bl   @room_event_caller
       bl   @upload_sprites
       inc  @frame
       .pop r2
       .endproc
*// animation_frame

*********************************************************************
*
* Reset lives
*
lives_reset:
       .proc
       li   r0,3
       mov  r0,@wally_lives
       li   r0,3
lives_reset_1:
       .push r0
       bl   @life_draw
       .pop r0
       dec  r0
       jne  lives_reset_1
       .endproc
*// lives_reset

*********************************************************************
*
* Draw life
*
* Input:
* r0: life number 0-
*
life_draw:
       .proc
       dec  r0
       sla  r0,4                       ; x16
       mov  r0,@bitmap_x
       li   r0,16
       mov  r0,@bitmap_y
       li   r0,>4c                     ; Index for Life Bitmap
       bl   @bitmap_16_draw
       .endproc
*// life_draw

*********************************************************************
*
* Wally init
*
wally_init:
       .proc
*      Allocate sprites for Wally
       bl   @allocate_sprite
       mov  r0,@wally_sprite_1
       ai   r0,3
       movb @byte_0f,*r0
       bl   @allocate_sprite
       mov  r0,@wally_sprite_2
       ai   r0,3
       movb @byte_0f,*r0
*      Set position
       li   r0,>9858
       mov  r0,@wally_y
       li   r0,>1000
       mov  r0,@wally_feet_dy
       li   r0,>0001
       mov  r0,@wally_feet_frame_offset
       movb r14,@wally_last_dir   ; Added by Rasmus
       .endproc
*// wally_init

*********************************************************************
*
* Wally reset
*
wally_reset
       .proc
       clr  r0
       movb r0,@wally_frame
       movb r0,@wally_head_turned
       movb r0,@wally_falling
       movb r0,@wally_dir
       movb r0,@wally_jump_dir
       movb r14,@wally_last_dir
       c    @wally_x,@byte_78
       jhe  wally_reset_0
       movb @byte_10,@wally_frame
       movb r13,@wally_last_dir
wally_reset_0:
       .endproc
*// wally_reset

*********************************************************************
*
* Draw Wally
*
wally_draw:
       .proc
*      Head
       mov  @wally_sprite_1,r4
       movb @wally_y,*r4+
       movb @wally_x,*r4+
       clr  r0
       movb @wally_frame,@r0lb
       movb @wally_head_turned,r1
       jeq  wally_draw_1
       ci   r0,>0010
       jhe  wally_draw_0
       ci   r0,>0000
       jeq  wally_draw_1
       ci   r0,>0008
       jeq  wally_draw_1
       ai   r0,>003e
       jmp  wally_draw_1
wally_draw_0:
       ci   r0,>0010
       jeq  wally_draw_1
       ci   r0,>001e
       jeq  wally_draw_1
       ai   r0,>002f
wally_draw_1:
       bl   @get_sprite_pattern
       movb r1,*r4+
*      Feet
       mov  @wally_sprite_2,r4
       movb @wally_y,r0
       ab   @wally_feet_dy,r0
       movb r0,*r4+
       movb @wally_x,r0
       ab   @wally_feet_dx,r0
       movb r0,*r4+
       clr  r0
       movb @wally_frame,@r0lb
       a    @wally_feet_frame_offset,r0
       bl   @get_sprite_pattern
       movb r1,*r4+
*      Record shifts
       mov  @wally_y,r0                ; Get y and x
       andi r0,7
       mov  r0,@wally_shift_value      ; x shift
       mov  @wally_y,r1
       swpb r1
       andi r1,7
       mov  r1,@wally_char_aligned     ; y shift
       .endproc
*// wally_draw

*********************************************************************
*
* Hide Wally
*
wally_erase:
       .proc
       li   r0,>c800
       mov  @wally_sprite_1,r1
       movb r0,*r1
       mov  @wally_sprite_2,r1
       movb r0,*r1
       bl   @upload_sprites
       .endproc
*// wally_erase

*********************************************************************
*
* Knock Wally down to the floor
*
wally_knocked_down:
       .proc
       szcb r14,@wally_head_turned
       mov  @wally_room_no,r1          ; Workout the position of the bottom floor in room.
       movb @wally_resurrect_y(r1),r2
wally_knocked_down_0:
       bl   @animation_frame
       movb @wally_y,r0
       ab   @byte_03,r0
       cb   r0,r2
       jh   wally_knocked_down_1
       movb r0,@wally_y
       jmp  wally_knocked_down_0
wally_knocked_down_1:
       movb @byte_9b,@wally_frame
       li   r2,6
wally_knocked_down_2:
       bl   @animation_frame
       dec  r2
       jne  wally_knocked_down_2
       movb @byte_9d,@wally_frame
       bl   @animation_frame
       .endproc
*// wally_knocked_down

*********************************************************************
*
* Check to see if Wally is colliding with another sprite.
*
* Input:
* r0: Amount to decrease wally's energy by
* r1 MSB: y position of other sprite
* r1 LSB: x position of other sprite
*
* Modifies r0-r5
*
wally_hit_test:
       .proc
       movb @death_flag,r0             ; Check to see if wally is dead, if so return.
       jne  wally_hit_test_1
       sb   @wally_y,r1                ; See if Y pos is within range of sprite's Y => (Wy-$0e > Sy < Wy+$0e)
       sb   @byte_1c,r1
       cb   r1,@byte_d6
       jl   wally_hit_test_1
       swpb r1
       sb   @wally_x,r1                ; See if X pos is within range of sprite's X => (Wx-$0D > Sx < Wx+$0D)
       sb   @byte_0d,r1
       cb   r1,@byte_e6
       jl   wally_hit_test_1
       bl   @milk_decrease_by_amount   ; Its a hit, so decrease energy and check for death.
wally_hit_test_1:
       .endproc
*// wally_hit_test

*********************************************************************
*
* Handles countdown which indicates the loss of energy.
*
energy_countdown:
       .proc
       abs  @demo_flag             ; Skip countdown?
       jne  energy_countdown_end
       dec  @energy_counter
       jne  energy_countdown_end
       li   r0,>012c
       mov  r0,@energy_counter
       li   r0,1
       bl   @milk_decrease_by_amount
energy_countdown_end:
       .endproc
*// energy_countdown

*********************************************************************
*
* Increases Wally's milk energy level by given amount.
*
* Input:
* r0: Amount to increasse by
*
milk_increase_by_amount:
       .proc
       clr  r2
       movb @milk_level,@r2lb
       s    r0,r2
       jgt  milk_increase_by_amount_1
       clr  r2
milk_increase_by_amount_1:
       movb  @r2lb,@milk_level
       li   r0,13*8                    ; Destination
       li   r1,bmp_milk_full           ; Source
       li   r2,32
       bl   @bmp_draw_lines
       li   r0,13*8                    ; Destination
       li   r1,bmp_milk_empty          ; Source
       clr  r2
       movb @milk_level,@r2lb
       bl   @bmp_draw_lines
       .endproc
*// milk_increase_by_amount

*********************************************************************
*
* Decreases Wally's milk energy level by given amount.
*
* Input:
* r0: Amount to decreasse by
*
* Modifies r0-r5
*
milk_decrease_by_amount:
       .proc
       clr  r2
       movb @milk_level,@r2lb
       .ifeq immunity,0
       a    r0,r2
       .endif
       ci   r2,32
       jlt  milk_decrease_by_amount_1
       li   r2,32
       movb r13,@death_flag
milk_decrease_by_amount_1:
       movb  @r2lb,@milk_level
       li   r0,13*8                    ; Destination
       li   r1,bmp_milk_empty          ; Source
       bl   @bmp_draw_lines
       .endproc
*// milk_decrease_by_amount

*********************************************************************
*
* Room enter
*
room_enter:
       .proc
       li   r0,>01a2                   ; Screen off
       bl   @vwtr
       bl   @mute_sound
       bl   @room_init
       bl   @deallocate_sprites
       bl   @wally_erase
       bl   @screen_clear_room
       bl   @room_draw
       bl   @inventory_redraw
       li   r0,>01e2                   ; Screen on
       bl   @vwtr
       .endproc
*// room_enter

*********************************************************************
*
* Room init
*
room_init:
       clr  r0
       movb r0,@flag_baddy_init
       movb r0,@flag_food_drawn
       movb r0,@flag_rolling_rock      ; F18A
       movb r0,@flag_balloon           ; F18B
       inc  r0
       mov  r0,@mag_lock_dir
       li   r0,>0030
       mov  r0,@spooky_hand_countdown
       li   r0,>0028
       movb r0,@room_0_rock_count
       movb @byte_30,@flag_mag_lock
       rt
*// room_init

*********************************************************************
*
* Display final score
*
display_final_score:
       .proc
       bl   @screen_clear
       li   r0,str_final_score
       li   r1,>0208
       bl   @string_draw_double
       mov  @steps_counter,r0
       li   r1,>070f
       li   r2,attr_46
       clr  r3
       bl   @display_number
       bl   @calculate_score
       mov  r3,r0
       li   r1,>100f
       li   r2,attr_47
       li   r3,2
       bl   @display_number
       bl   @wait_key
       .endproc
*// display_final_score

*********************************************************************
*
* Calculates the overall percentage score using how many rooms visited
* and which objects collected.
*
* r3: holds the total score on exit.
*
calculate_score:
       .proc
       li   r1,object_found_table      ; Table holding which objects collected and percentage values of each object
       li   r2,>20                     ; Number of objects
       clr  r3                         ; Total percent
calculate_score_0:
       mov  *r1+,r0
       cb   r0,r13                ; See if objects has been picked up
       jne  calculate_score_1          ; Skip object (if not marked as carried)
       andi r0,>00ff
       a    r0,r3                      ; If it has, then add value of object to total percentage.
calculate_score_1:
       dec  r2
       jne  calculate_score_0
       li   r1,rooms_visited_table
       li   r2,>001e
       clr  r0
calculate_score_2:
       movb *r1+,@r0lb
       a    r0,r3
       dec  r2
       jne  calculate_score_2
       .endproc
*// calculate_score

*********************************************************************
*
* Draw a decimal number
*
* Input:
* r0: number to display
* r1: MSB: y position (chars)
* r1: LSB: x position (chars)
* r2: MSB: color
* r3: Width
*
display_number:
       .proc
       mov  r0,r4                      ; Number
       mov  r1,r5                      ; Position
       mov  r3,r6                      ; Width
display_number_1:
       clr  r3                         ; MSB
       li   r1,10                      ; Divisor
       div  r1,r3                      ; Divide r3-r4 by 10
       mov  r4,r0                      ; Remainder
       mov  r3,r4
       ai   r0,>30                     ; Add tile number for zero
       swpb r0
       mov  r5,r1                      ; Position
       bl   @tile_draw_double_height
       mov  r6,r6
       jne  display_number_2
       mov  r4,r4
       jeq  display_number_3
       dec  r5
       jmp  display_number_1
display_number_2:
       dec  r5
       dec  r6
       jne  display_number_1
display_number_3:
       .endproc
*// display_number

*********************************************************************
*
* Redraw inventory area
*
inventory_redraw:
       .proc
       bl   @inventory_clear
       li   r0,bmp_tiles               ; Reset the start address of the tiles back to tile zero
       mov  r0,@tile_start_ptr
       mov  @pocket_1,r1
       sla  r1,1
       mov  @object_text_ptr_table(r1),r0
       li   r1,>0014
       li   r2,attr_44
       bl   @inventory_draw_text
       mov  @pocket_2,r1
       sla  r1,1
       mov  @object_text_ptr_table(r1),r0
       li   r1,>0214
       li   r2,attr_45
       bl   @inventory_draw_text
       mov  @pocket_1,r0
       ai   r0,>50
       li   r1,>0088
       mov  r1,@bitmap_x
       clr  @bitmap_y
       bl   @bitmap_16_draw
       mov  @pocket_2,r0
       ai   r0,>50
       li   r1,>0010
       mov  r1,@bitmap_y
       bl   @bitmap_16_draw
       .endproc
*// inventory_redraw

*********************************************************************
*
* Clear inventory area
*
inventory_clear:
       .proc
       li   r0,17*8
       li   r2,4
inventory_clear_1:
       bl   @vwad
       li   r3,15*8
inventory_clear_2:
       clr  *r15
       dec  r3
       jne  inventory_clear_2
       ai   r0,256
       dec  r2
       jne  inventory_clear_1
       .endproc
*// inventory_clear

*********************************************************************
*
* Draws the text for an object in a pocket
*
* Input:
*
* r0: Address of text string
* r1 MSB: y position
* r1 LSB: x position
* r2 MSB: color
*
inventory_draw_text:
       .proc
       mov  r0,r4
inventory_draw_text_7:
       movb *r4+,r0
       jgt  inventory_draw_text_0
       cb   r0,r14
       jeq  inventory_draw_text_1
       cb   r0,@byte_fc
       jne  inventory_draw_text_0
       ab   *r4+,@r1lb
       ab   *r4+,r1
       jmp  inventory_draw_text_7
inventory_draw_text_0:
       .push r1
       bl   @tile_draw
       .pop r1
       inc  r1
       jmp  inventory_draw_text_7
inventory_draw_text_1:
       movb *r4,r0
       cb   r0,@byte_fa
       jne  inventory_draw_text_8
       ci   r2,attr_44
       jne  inventory_draw_text_2
       mov  @pocket_1,r3
       jmp  inventory_draw_text_3
inventory_draw_text_2:
       mov  @pocket_2,r3
inventory_draw_text_3:
       ci   r3,>0d
       jne  inventory_draw_text_4
       li   r3,flag_laser_gun
       jmp  inventory_draw_text_6
inventory_draw_text_4:
       ci   r3,>08
       jne  inventory_draw_text_5
       li   r3,flag_fuel_can
       jmp  inventory_draw_text_6
inventory_draw_text_5:
       li   r3,flag_water_bucket
inventory_draw_text_6:
       inc  r1
       li   r4,txt_full
       li   r2,>a100
       movb *r3,r5
       jne  inventory_draw_text_7
       li   r4,txt_empty
       jmp  inventory_draw_text_7
inventory_draw_text_8:
       .endproc
txt_full:
       text "FULL"
       byte >ff
txt_empty:
       text "EMPTY"
       byte >ff
       even
*// inventory_draw_text

*********************************************************************
*
* Room draw
*
room_draw:
       .proc
       mov  @wally_room_no,r4          ; Get room number.
       sla  r4,1                       ; Work out address of room pointer.
       mov  @room_data(r4),r4          ; Get address to room description data.
       movb *r4,r0
       cb   r0,@byte_f5                ; Get first byte and test for drawing of walls etc.
       jne  room_draw_1
       bl   @draw_ceiling_wall_floor
       inc  r4
*      Draw furniture
room_draw_1:
       movb *r4+,r0
       cb   r0,r14
       jeq  room_draw_5                ; End marker
       cb   r0,@byte_f4
       jne  room_draw_2
       seto @tile_flip_vertical             ; Draw upside down
       jmp  room_draw_1
room_draw_2:
       cb   r0,@byte_f3
       jne  room_draw_3
       clr  @tile_flip_vertical             ; Draw normal
       jmp  room_draw_1
room_draw_3:
       cb   r0,@byte_de
       jne  room_draw_4
       movb *r4+,@r1lb                 ; Get address of action flag.
       movb *r4+,r1
       movb *r1,r0                     ; Get action flag
       jeq  room_draw_5                ; If not set then handle action,
       jmp  room_draw_1                ; else continue onto next byte.
room_draw_4:
       swpb r0
       movb *r4+,r0                    ; y position (x in MSB)
       clr  r1
       movb *r4+,@r1lb                 ; Get index of furniture item.
       sla  r1,1
       mov  @furniture_table(r1),r1    ; Workout address of item string.
       bl   @furniture_draw
       jmp  room_draw_1
*      Draw object
room_draw_5:
       mov  @wally_room_no,r3
       sla  r3,1                       ; x2
       a    @wally_room_no,r3          ; x3
       ai   r3,room_obj_slots
       clr  r0
       movb *r3+,@r0lb                 ; Get x
       mov  r0,@bitmap_x
       movb *r3+,@r0lb                 ; Get y
       ai   r0,>10                     ; Y values are offset by -16
       mov  r0,@bitmap_y
       movb *r3,@r0lb
       ai   r0,>50
       bl   @bitmap_16_draw
       .endproc
*// room_draw

*********************************************************************
*
* Draw furniture
*
* Input:
* r0 MSB: y position
* r0 LSB: x position
* r1: Address of furniture item string
*
furniture_draw:
       .proc
       mov  r1,r5                      ; Save address
       mov  r0,r6                      ; Save position
furniture_draw_6:
       movb *r5+,r0                    ; Get next byte in string.
       jgt  furniture_draw_4           ; Test for normal tile.
       jeq  furniture_draw_4
       cb   r0,r14                ; Test for END OF STRING value.
       jeq  furniture_draw_5
       cb   r0,@byte_fe                ; Test for code.
       jne  furniture_draw_0
       movb *r5+,r0                    ; Get colour.
       bl   @ti_color                  ; Convert to TI color
       mov  r1,r7                      ; Save color
       jmp  furniture_draw_6
furniture_draw_0:
       cb   r0,@byte_fc                ; Test for code.
       jne  furniture_draw_1
       ab   *r5+,@r6lb                 ; Px += Sx
       ab   *r5+,r6                    ; Py += Sy
       jmp  furniture_draw_6
furniture_draw_1:
       cb   r0,@byte_fb                ; Test for code.
       jne  furniture_draw_2
       movb *r5+,@r0lb                 ; Get next two bytes holding new tile start address.
       movb *r5+,r0
       ci   r0,>c1a0
       jl  !
       ai   r0,bmp_tiles->c1a0         ; Adjust address
       jmp  !!
!      ai   r0,tile_ceiling->8c4d      ; Adjust address for ceiling/roof/floor tiles
!      mov  r0,@tile_start_ptr         ; Store for tile_draw to use
       jmp  furniture_draw_6
furniture_draw_2:
       clr  r8
       movb *r5+,@r8lb                 ; Get number of times to draw.
       movb *r5+,r9                    ; Get tile(n) to draw.
furniture_draw_3:
       mov  r9,r0                      ; Tile number
       mov  r6,r1                      ; Position
       mov  r7,r2                      ; Color
       bl   @tile_draw                 ; Draw tile.
       inc  r6                         ; Px++
       dec  r8
       jne  furniture_draw_3
       jmp  furniture_draw_6
furniture_draw_4:
       mov  r6,r1                      ; Position
       mov  r7,r2                      ; Color
       bl   @tile_draw
       inc  r6                         ; Px++
       jmp  furniture_draw_6
furniture_draw_5:
       .endproc
*// furniture_draw

*********************************************************************
*
* Draw ceiling, wall and floor
*
draw_ceiling_wall_floor:
       .proc
       li   r0,tile_ceiling
       mov  r0,@tile_start_ptr
*      Ceiling
       li   r2,attr_43
       li   r6,>0500
       li   r8,>20
draw_ceiling_wall_floor_1:
       clr  r0
       mov  r6,r1
       bl   @tile_draw
       inc  r6
       dec  r8
       jne  draw_ceiling_wall_floor_1
*      Floor
       li   r2,attr_45
       li   r6,>1700
       li   r8,>20
draw_ceiling_wall_floor_2:
       li   r0,>0100
       mov  r6,r1
       bl   @tile_draw
       inc  r6
       dec  r8
       jne  draw_ceiling_wall_floor_2
*      Left wall
       li   r2,attr_42
       li   r6,>0600
       li   r8,>11
draw_ceiling_wall_floor_3:
       li   r0,>0200
       mov  r6,r1
       bl   @tile_draw
       ab   r13,r6
       dec  r8
       jne  draw_ceiling_wall_floor_3
*      Right wall
       li   r6,>061f
       li   r8,>11
draw_ceiling_wall_floor_4:
       li   r0,>0200
       mov  r6,r1
       bl   @tile_draw
       ab   r13,r6
       dec  r8
       jne  draw_ceiling_wall_floor_4
       .endproc
*// draw_ceiling_wall_floor

*********************************************************************
*
* Draw full milk glass
*
milk_draw_full:
       .proc
       li   r0,13*8                    ; Destination
       li   r1,bmp_milk_full
       li   r2,32                      ; 32 lines
       bl   @bmp_draw_lines
       .endproc
*// milk_draw_full

*********************************************************************
*
* Draw a number of lines of a bitmap.
* Bitmap width is 24 pixels.
*
* r0: Destination VDP address
* r1: Bitmap to draw
* r2: Number of lines to draw
*
* Modifies r0-r5
*
bmp_draw_lines:
       .proc
       mov  r2,r5
       srl  r2,3                       ; Number of rows of 8 lines
       jeq  bmp_draw_lines_4
*      Full rows
bmp_draw_lines_1:
       bl   @vwad
       li   r3,3                       ; 3 columns
bmp_draw_lines_2:
       li   r4,8                       ; 8 lines per row
bmp_draw_lines_3:
       movb *r1+,*r15
       inct r1                         ; Source increased by 3
       dec  r4
       jne  bmp_draw_lines_3
       ai   r1,-23                     ; Next source column: 24 back + 1 forward
       dec  r3
       jne  bmp_draw_lines_2
       ai   r0,256                     ; Next VDP row
       ai   r1,21                      ; Next source row: 7 lines down
       dec  r2
       jne  bmp_draw_lines_1
*      Remaining lines
bmp_draw_lines_4:
       andi r5,7                       ; Number of lines left
       jeq  bmp_draw_lines_7
       li   r3,3                       ; 3 columns
bmp_draw_lines_5:
       bl   @vwad
       mov  r1,r2                      ; Save source address
       mov  r5,r4                      ; Number of lines
bmp_draw_lines_6:
       movb *r1+,*r15
       inct r1                         ; Source increased by 3
       dec  r4
       jne  bmp_draw_lines_6
       ai   r0,8                       ; Next VDP column
       mov  r2,r1                      ; Restore source address
       inc  r1                         ; Next column
       dec  r3
       jne  bmp_draw_lines_5
bmp_draw_lines_7:
       .endproc
*// bmp_draw_lines

*********************************************************************
*
* Display a string using double height characters
*
* Input:
* r0: Pointer to string
* r1 MSB: y position (chars)
* r1 LSB: x position (chars)
*
string_draw_double:
       .proc
       mov  r0,r4                      ; String pointer
       mov  r1,r5                      ; Position
string_draw_double_1:
       movb *r4+,r0                    ; Get next character in string.
       jgt  string_draw_double_3       ; Bytes below $80 just get drawn.
       cb   r0,r14                ; End of string.
       jeq  string_draw_double_4
       cb   r0,@byte_fe                ; Character code for change colour.
       jne  string_draw_double_2
       movb *r4+,r0                    ; Get colour from next byte in string.
       bl   @ti_color                  ; Convert to TI color
       mov  r1,r2
       jmp  string_draw_double_1
string_draw_double_2:
       cb   r0,@byte_fc                ; Character code for offset position.
       jne  string_draw_double_3
       ab   *r4+,@r5lb                 ; Offset X position by 2nd byte.
       ab   *r4+,r5                    ; Offset Y position by 3rd byte.
       jmp  string_draw_double_1
string_draw_double_3:
       mov  r5,r1                      ; Position
       bl   @tile_draw_double_height   ; Draw character and move onto next column.
       inc  r5
       jmp  string_draw_double_1
string_draw_double_4:
       .endproc
*// string_draw_double

*********************************************************************
*
* Draw tile and color attribute
*
* Input:
* r0 MSB: Tile number
* r1 MSB: y position (chars)
* r1 LSB: x position (chars)
* r2 MSB: color
*
* Modifies r1,r3
*
tile_draw:
       .proc
*      Draw color
       bl   @set_attribute             ; r3 contains VDP address
*      Draw tile
       clr  r1
       movb r0,@r1lb                   ; Tile number
       sla  r1,3                       ; *8
       a    @tile_start_ptr,r1         ; Add base address
       movb @r3lb,@vdpwa               ; Send low byte of VDP RAM write address
       ori  r3,>4000
       movb r3,@vdpwa                  ; Send high byte of VDP RAM write address
       abs  @tile_flip_vertical
       jne  tile_draw_1
*      Draw normal tile
       movb *r1+,*r15
       movb *r1+,*r15
       movb *r1+,*r15
       movb *r1+,*r15
       movb *r1+,*r15
       movb *r1+,*r15
       movb *r1+,*r15
       movb *r1+,*r15
       jmp  tile_draw_2
tile_draw_1:
*      Draw upside down tile
       ai   r1,7
       movb *r1,*r15
       dec  r1
       movb *r1,*r15
       dec  r1
       movb *r1,*r15
       dec  r1
       movb *r1,*r15
       dec  r1
       movb *r1,*r15
       dec  r1
       movb *r1,*r15
       dec  r1
       movb *r1,*r15
       dec  r1
       movb *r1,*r15
       dec  r1
tile_draw_2:
       .endproc
*// tile_draw

*********************************************************************
*
* Draw double height tile and color attributes
*
* Input:
* r0 MSB: Tile number
* r1 MSB: y position (chars)
* r1 LSB: x position (chars)
* r2 MSB: color
*
* Modifies r0,r1,r3
*
tile_draw_double_height:
       .proc
*      Draw color
       .push r1
       bl   @set_attribute
       .pop r1
       ab   r13,r1
       bl   @set_attribute             ; r3 contains VDP address
       ai   r3,->0100
*      Draw tile
       clr  r1
       movb r0,@r1lb                   ; Tile number
       sla  r1,3                       ; *8
       a    @tile_start_ptr,r1         ; Add base address
       li   r0,2
tile_draw_double_height_1:
       movb @r3lb,@vdpwa               ; Send low byte of VDP RAM write address
       ori   r3,>4000
       movb r3,@vdpwa                  ; Send high byte of VDP RAM write address
       movb *r1,*r15
       movb *r1+,*r15
       movb *r1,*r15
       movb *r1+,*r15
       movb *r1,*r15
       movb *r1+,*r15
       movb *r1,*r15
       movb *r1+,*r15
       ai   r3,>0100
       dec  r0
       jne  tile_draw_double_height_1
       .endproc
*// tile_draw_double_height

*********************************************************************
*
* set color attribute at character position
*
* Input:
* r1 MSB: y position (chars)
* r1 LSB: x position (chars)
* r2 MSB: color
*
* On return:
* r3: VDP address
* Modifies r1
*
set_attribute:
*      Bitmap screen position
       mov  r1,r3                      ; 000yyyyy000xxxxx
       andi r3,>001f                   ; 00000000000xxxxx
       sla  r3,3                       ; 00000000xxxxx000
       andi r1,>1f00                   ; 000yyyyy00000000
       abs  @tile_flip_vertical
       jeq  !
       neg  r1                         ; -y
       ai   r1,>1C00                   ; 28-y
!      movb r1,r3                      ; 000yyyyyxxxxx000
*      Draw color
       mov  r3,r1
       movb @r1lb,@vdpwa               ; Send low byte of VDP RAM write address
       ai   r1,>4000+colrtb
       movb r1,@vdpwa                  ; Send high byte of VDP RAM write address
       movb r2,*r15
       movb r2,*r15
       movb r2,*r15
       movb r2,*r15
       movb r2,*r15
       movb r2,*r15
       movb r2,*r15
       movb r2,*r15
*      Update attribute table
       mov  r3,r1                      ; 000yyyyyxxxxx000
       srl  r1,3                       ; 000000yyyyyxxxxx
       movb r2,@attr_table(r1)
       rt
*// set_attribute

*********************************************************************
*
* Get color attribute at pixel position
*
* Input:
* r0 MSB: y position
* r0 LSB: x position
*
* On return:
* r0 MSB: attribute value
* r1: attribute table address
*
get_attribute:
       mov  r0,r1
       andi r0,>00f8
       srl  r0,3
       andi r1,>f800
       srl  r1,6
       soc  r0,r1
       ai   r1,attr_table
       movb *r1,r0
       rt
*// get_attribute

*********************************************************************
*
* Erase 16x16 bitmap
* (erases full characters only)
*
* Modifies r0-r5
*
bitmap_16_erase:
       .proc
       mov  @bitmap_x,r0
       mov  @bitmap_y,r1
       li   r3,2                       ; Rows
       li   r4,2                       ; Cols
       li   r5,7
       czc  r5,r0                      ; Check if char aligned
       jeq  bitmap_16_erase_1
       inc  r4                         ; One more column
       andi r0,>00f8                   ; Align
bitmap_16_erase_1:
       czc  r5,r1                      ; Check if char aligned
       jeq  bitmap_16_erase_2
       inc  r3                         ; One more row
bitmap_16_erase_2:
       srl  r1,3                       ; Align
       movb @r1lb,r0                   ; Screen address
       sla  r4,3                       ; 8 bytes per column
bitmap_16_erase_3:
       bl   @vwad
       mov  r4,r2
bitmap_16_erase_4:
       clr  *r15
       dec  r2
       jne  bitmap_16_erase_4
       ai   r0,>0100
       dec  r3
       jne  bitmap_16_erase_3
       .endproc
*// bitmap_16_erase_fast

*********************************************************************
*
* Draw 16x16 bitmap
*
* Input:
* r0: Index of bitmap to draw
* @bitmap_x: x coordinate
* @bitmap_y: y coordinate
*
* MOdifies r0-r9
*
bitmap_16_draw:
       .proc
       li   r4,bmp_wally
       sla  r0,5
       a    r0,r4                      ; Source address
       mov  @bitmap_x,r0
       mov  @bitmap_y,r1
       bl   @screen_address            ; Result in r6,r7
       ori  r6,>4000                   ; Setup as write address
*      Setup shifts
       mov  r7,r0                      ; Bit offset
       jeq  bitmap_16_draw_1
       mov  @opcode_srl,r8             ; Right shift by offset
       sla  r0,4
       soc  r0,r8
       mov  @opcode_sla,r9             ; Left shift by (8-offset)
       li   r0,8
       s    r7,r0
       sla  r0,4
       soc  r0,r9
       jmp  bitmap_16_draw_2
bitmap_16_draw_1:
       mov  @opcode_nop,r8             ; No shift
       mov  r8,r9
*      1-8 lines of first character row
bitmap_16_draw_2:
       mov  r6,r0
       andi r0,7
       li   r3,8                       ; Line counter
       s    r0,r3
       bl   @bitmap_16_draw_section
*      Full character row
       ai   r6,>0100                   ; Next character row
       andi r6,>fff8                   ; Align to beginning of row
       li   r3,8
       bl   @bitmap_16_draw_section
*      0-7 lines of last character row
       mov  @bitmap_y,r3
       andi r3,7
       jeq  bitmap_16_draw_3
       ai   r6,>0100                   ; Next character row
       andi r6,>fff8                   ; Align to beginning of row
       bl   @bitmap_16_draw_section
bitmap_16_draw_3:
       .endproc
bitmap_16_draw_section:
       mov  r6,r5
*      First byte
       movb @r5lb,@vdpwa               ; Setup VDP write address
       movb r5,@vdpwa
       mov  r4,r0                      ; Source address
       mov  r3,r2
bitmap_16_draw_section_1:
       mov  *r0+,r1                    ; Get source word
       x    r8                         ; Shift right
       movb r1,*r15                    ; Send MSB to VDP
       dec  r2
       jne  bitmap_16_draw_section_1
*      Second byte
       ai   r5,8
       movb @r5lb,@vdpwa               ; Setup VDP write address
       movb r5,@vdpwa
       mov  r4,r0                      ; Source address
       mov  r3,r2
bitmap_16_draw_section_2:
       mov  *r0+,r1                    ; Get source word
       x    r8                         ; Shift right
       movb @r1lb,*r15                 ; Send LSB to VDP
       dec  r2
       jne  bitmap_16_draw_section_2
*      Third byte
       abs  r7
       jeq  bitmap_16_draw_section_4
       ai   r5,8
       movb @r5lb,@vdpwa               ; Setup VDP write address
       movb r5,@vdpwa
       mov  r4,r0                      ; Source address
       mov  r3,r2
bitmap_16_draw_section_3:
       mov  *r0+,r1                    ; Get source word
       x    r9                         ; Shift left
       movb @r1lb,*r15                 ; Send LSB to VDP
       dec  r2
       jne  bitmap_16_draw_section_3
bitmap_16_draw_section_4:
       mov  r0,r4
       rt
opcode_srl:
       srl  r1,0
opcode_sla:
       sla  r1,0
opcode_nop:
       nop
*// bitmap_16_draw

*********************************************************************
*
* Initialize sprites
*
init_sprites:
       .proc
*      Sprite pattern+bitmap map
       bl   @init_sprite_maps
*      Sprite table
       li   r0,sprite_table
       li   r1,>c000
       li   r2,sprite_table_size
init_sprites_1:
       mov  r1,*r0+
       clr  *r0+
       dec  r2
       jne  init_sprites_1
*      Set max sprite
       seto @max_sprite
       .endproc
*// init_sprites

*********************************************************************
*
* Initialize sprite maps
*
init_sprite_maps:
       li   r0,sprite_pattern_map
       li   r2,sprite_pattern_map_size+sprite_bitmap_map_size
init_sprite_maps_1:
       seto *r0+                       ; Set all to >ff
       dect r2
       jne  init_sprite_maps_1
       rt
*// init_sprite_maps

*********************************************************************
*
* Allocate sprite
*
* On return r0 contains the address of the allocated sprite
* or 0 if allocation failed.
*
* Modifies r1-r2
*
allocate_sprite:
       .proc
       li   r0,sprite_table
       li   r1,>c000
       li   r2,sprite_table_size
allocate_sprite_1:
       cb   *r0,r1
       jeq  allocate_sprite_2
       ai   r0,4
       dec  r2
       jne  allocate_sprite_1
       clr  r0
       jmp  allocate_sprite_3
allocate_sprite_2:
       szcb r14,*r0
       mov  r0,r1
       ai   r1,-sprite_table
       srl  r1,2
       c    r1,@max_sprite
       jlt  allocate_sprite_3
       mov  r1,@max_sprite
allocate_sprite_3:
       .endproc
*// allocate_sprite

*********************************************************************
*
* Deallocate sprite
*
* Input:
* r0: address of the allocated sprite
*
* Modifies r0
*
deallocate_sprite:
       .proc
       movb @byte_c0,*r0
       mov  @max_sprite,r0
       sla  r0,2
       ai   r0,sprite_table
deallocate_sprite_1:
       cb   *r0,@byte_c0
       jne  deallocate_sprite_2
       dec  @max_sprite
       ai   r0,-sprite_size
       jgt  deallocate_sprite_1
deallocate_sprite_2:
       .endproc
*// deallocate_sprite

*********************************************************************
*
* Deallocate all sprites except Wally
*
deallocate_sprites:
       .proc
       li   r0,sprite_table+(2*sprite_size)
       li   r1,>c000
       mov  @max_sprite,r2
       dec  r2
       jlt  deallocate_sprites_2
       jeq  deallocate_sprites_2
deallocate_sprites_1:
       mov  r1,*r0+
       clr  *r0+
       dec  r2
       jne  deallocate_sprites_1
*      Set max sprite
deallocate_sprites_2:
       li   r0,1
       mov  r0,@max_sprite
*      Garbage collect
       bl   @garbage_collect_sprites
       .endproc
*// deallocate_sprites

*********************************************************************
*
* Upload sprites to VDP
*
upload_sprites:
       .proc
       li   r0,spratb
       bl   @vwad
       mov  @max_sprite,r2
       jlt  upload_sprites_2
       inc  r2
       li   r1,sprite_table
upload_sprites_1:
       movb *r1+,r0                    ; y
       ai   r0,->0100                  ; Adjust y coord
       movb r0,*r15
       movb *r1+,*r15                  ; x
       movb *r1+,*r15                  ; pattern
       movb *r1+,*r15                  ; color
       dec  r2
       jne  upload_sprites_1
upload_sprites_2:
       movb @byte_d0,*r15
       .endproc
*// upload_sprotes

*********************************************************************
*
* Get sprite pattern no corresponding to the given bitmap no.
* Upload sprite pattern if not already present.
*
* Input:
* r0: Index of bitmap
*
* On return r1 MSB contains the pattern no
* Modifies r0-r3
*
get_sprite_pattern:
       .proc
get_sprite_pattern_0:
       mov  r0,r3
       movb @sprite_pattern_map(r3),r1
       cb   r1,r14
       jne  get_sprite_pattern_5
       li   r0,sprite_bitmap_map
       li   r2,sprite_bitmap_map_size
get_sprite_pattern_1:
       cb   *r0+,r1
       jeq  get_sprite_pattern_2
       dec  r2
       jne  get_sprite_pattern_1
*      Not found
       bl   @garbage_collect_sprites
       jmp  get_sprite_pattern_0       ; Restart
get_sprite_pattern_2:
       dec  r0                         ; Backtrack
       movb  @r3lb,*r0                 ; Update sprite_bitmap_map
       ai   r0,-sprite_bitmap_map      ; To index
       mov  r0,r1
       sla  r1,2
       swpb r1                         ; Return value
       movb r1,@sprite_pattern_map(r3) ; Update sprite_pattern_map
       sla  r0,5                       ; x32
       ai   r0,sprptb
       bl   @vwad
       sla  r3,5
       ai   r3,bmp_wally               ; Source
*      Upload column 1
       li   r2,16
get_sprite_pattern_3:
       mov  *r3+,*r15
       dec  r2
       jne get_sprite_pattern_3
*      Upload column 2
       ai   r3,-31
       li   r2,16
get_sprite_pattern_4:
       movb *r3,*r15
       inct r3
       dec  r2
       jne get_sprite_pattern_4
get_sprite_pattern_5:
       .endproc
*// get_sprite_pattern

*********************************************************************
*
* Garbage collect sprite patterns
*
garbage_collect_sprites:
       .proc
*      Copy existing
       li   r0,sprite_pattern_map
       li   r1,sprite_pattern_map_alt
       li   r2,sprite_pattern_map_size+sprite_bitmap_map_size
garbage_collect_1:
       mov  *r0+,*r1+
       dect r2
       jne  garbage_collect_1
*      Clear existing
       bl   @init_sprite_maps
*      Copy back used
       li   r0,sprite_table
       mov  @max_sprite,r2
       inc  r2
garbage_collect_2:
       cb   *r0,@byte_c0               ; Check if used
       jeq  garbage_collect_3
       inct r0
       clr  r1
       movb *r0,@r1lb                  ; Get pattern
       srl  r1,2
       ai   r1,sprite_bitmap_map_alt
       clr  r3
       movb *r1,@r3lb
       ai   r3,sprite_pattern_map_alt
       movb *r1,@sprite_pattern_map-sprite_pattern_map_alt(r1)
       movb *r3,@sprite_bitmap_map-sprite_bitmap_map_alt(r3)
garbage_collect_3:
       inct r0
       dec  r2
       jne  garbage_collect_2
       .endproc
*// garbage_collect_sprites

*********************************************************************
*
* Calculate screen address and bit mask from coordinates
* Based on E/A manual page 336
*
* Input:
* r0 x value
* r1 y value
*
* On return:
* r6  Set to byte offset
* r7  Set to bit offset
*
screen_address:
       mov  r1,r6                      ; 00000000yyyyyyyy
       sla  r6,5                       ; 000yyyyyyyy00000
       soc  r1,r6                      ; 000yyyyy???yyyyy
       andi r6,>ff07                   ; 000yyyyy00000yyy
       mov  r0,r7                      ; 00000000xxxxxxxx
       andi r7,7                       ; 0000000000000xxx
       a    r0,r6                      ; 000yyyyyxxxxx???
       s    r7,r6                      ; 000yyyyyxxxxxyyy
       rt
*// screen_address

*********************************************************************
*
* Get TI-99 color from ZX Spectrum color
*
* r0 MSB: Colour-byte FBPPPIII
*  - I - Ink colour (0-7)
*  - P - Paper colour (0-7)
*  - B - Bright (0-No, 1-Yes)
*  - F - Flash  (0-No, 1-Yes)
*
* Modifies r2-r3
* On return r1 MSB contains the TI color FFFFBBBB.
*
ti_color:
       clr  r1
*      Foreground
       mov  r0,r2
       andi r2,>0700                   ; Foreground bits
       mov  r0,r3
       andi r3,>4000                   ; Bright bit
       srl  r3,3
       soc  r3,r2
       swpb r2
       movb @tipal(r2),r1
       sla  r1,4
*      Background
       mov  r0,r2
       andi r2,>3800                   ; Background bits
       srl  r2,3
       soc  r3,r2
       swpb r2
       movb @tipal(r2),r3
       socb r3,r1
*      Flash                           ; Invert
       andi r0,>8000
       jeq  !
       srl  r1,4
       andi r1,>0ff0
       socb @r1lb,r1
!      rt

* Spectrum palette
* 0  Black,    1 D Blue,   2 D Red,     3 D Magenta
* 4  D Green,  5 D Cyan,   6 D Yellow,  7 Grey
* 8  Black,    9 Blue,    10 Red,      11 Magenta
* 12 Green,   13 Cyan,    14 Yellow,   15 White

* TI palette
* 0  Trans,    1 Black,    2 M Green,   3 L Green
* 4  D Blue,   5 L Blue,   6 D Red,     7 Cyan
* 8  M Red,    9 L Red,   10 D Yellow, 11 L Yellow
* 12 D Green, 13 Magenta, 14 Gray,     15 White

tipal  byte 1,4,6,13,12,7,10,14,1,5,8,13,2,7,11,15
* Not used: 3 L Green, 9 L Red
* Not available: D Cyan, D Magenta
*// ti_color

*********************************************************************
*
* Wait for vertical retrace
*
vsync:
       movb @vdpsta,r12
vsync_1:
       movb @vdpsta,r12
       jgt  vsync_1
       jeq  vsync_1
       rt
*// vsync

*********************************************************************
*
* Clear whole screen
*
screen_clear:
       .proc
*      Sprites
       li   r0,spratb
       li   r1,>d000
       bl   @vsbw
*      Patterns
       li   r0,ptrntb
       li   r1,>0000
       li   r2,>500
       bl   @vsmw
*      Colors
       li   r0,colrtb
       li   r1,attr_46
       li   r2,>500
       bl   @vsmw
*      Attributes
       li   r0,attr_table
       li   r1,attr_46
       li   r2,>a0
screen_clear_1:
       movb r1,*r0+
       dec  r2
       jne  screen_clear_1
       bl   @screen_clear_room
       .endproc
*// screen_clear

*********************************************************************
*
* Clear room area of screen
*
screen_clear_room:
       .proc
*      Patterns
       li   r0,ptrntb+>500
       li   r1,>0000
       li   r2,>1800->500
       bl   @vsmw
*      Colors
       mov  @wally_room_no,r1
       movb @room_color_table(r1),r0
       bl   @ti_color
       li   r0,colrtb+>500
       li   r2,>1800->500
       bl   @vsmw
*      Attributes
       li   r0,attr_table+(5*32)
       li   r2,>300-(5*32)
screen_clear_room_1:
       movb r1,*r0+
       dec  r2
       jne  screen_clear_room_1
       .endproc
*// screen_clear_room

*********************************************************************
*
* Set full bitmap mode
*
bitmap_mode:
       .proc
       clr  r0
       li   r1,vregs2
       li   r2,8
bitmap_mode_1:
       movb *r1+,@r0lb
       bl   @vwtr                      ; Set register
       ai   r0,>0100
       dec  r2
       jne  bitmap_mode_1
*      Name table
       li   r0,nametb
       bl   @vwad
       clr  r1
       li   r2,>300
bitmap_mode_2:
       movb r1,*r15
       ai   r1,>0100
       dec  r2
       jne  bitmap_mode_2
*      Sprite attributes
       li   r0,spratb
       li   r1,>d000
       bl   @vsbw
*      Return
       .endproc
*      VDP registers
vregs2:
       byte >02                        ; Graphics II mode
       byte >e2                        ; 16K, display on, interrupt enabled
       byte nametb/>400                ; Name table
       byte >ff                        ; Color table
       byte ptrntb/>800+>03            ; Pattern table
       byte spratb/>80                 ; Sprite attribute table
       byte sprptb/>800                ; Sprite pattern table
       byte >01                        ; Backdrop color
*// bitmap_mode

*********************************************************************
*
* VDP Write To Register
*
* R0 MSB: VDP register to write to
* R0 LSB: Value to write
*
vwtr:
       swpb r0
       movb r0,@vdpwa                  ; Send low byte (value) to write to VDP register
       swpb r0
       ori  r0,>8000                   ; Set up a VDP register write operation (10)
       movb r0,@vdpwa                  ; Send high byte (address) of VDP register
       rt
*// vwtr

*********************************************************************
*
* VDP Set Write Address
*
* R0: Write address in VDP RAM
*
* R0 is modified, but can be restored with: ANDI R0,>3FFF
*
vwad:
       swpb r0
       movb r0,@vdpwa                  ; Send low byte of VDP RAM write address
       swpb r0
       ori  r0,>4000                   ; Set read/write bits 14 and 15 to write (01)
       movb r0,@vdpwa                  ; Send high byte of VDP RAM write address
       rt
*// vwad

*********************************************************************
*
* VDP Set Read Address
*
* R0: Read address in VDP RAM
*
vrad:
       swpb r0
       movb r0,@vdpwa                  ; Send low byte of VDP RAM red address
       swpb r0
       movb r0,@vdpwa                  ; Send high byte of VDP RAM read address
       rt
*// vrad

*********************************************************************
*
* VDP Single Byte Read
*
* R0   Read address in VDP RAM
* R1   MSB of R1 set to byte from VDP RAM
*
vsbr:
       movb @r0lb,@vdpwa               ; Send low byte of VDP RAM write address
       andi r0,>3fff
       movb r0,@vdpwa                  ; Send high byte of VDP RAM write address
       movb @vdprd,r1                  ; Read byte from VDP RAM
       rt
*// vsbr

*********************************************************************
*
* VDP Single Byte Write
*
* R0: Write address in VDP RAM
* R1: MSB of R1 sent to VDP RAM
*
* R0 is modified, but can be restored with: ANDI R0,>3FFF
*
vsbw:
       movb  @r0lb,@vdpwa              ; Send low byte of VDP RAM write address
       ori  r0,>4000                   ; Set read/write bits 14 and 15 to write (01)
       movb r0,@vdpwa                  ; Send high byte of VDP RAM write address
       movb r1,*15                     ; Write byte to VDP RAM
       rt
*// vsbw

*********************************************************************
*
* VDP Single Byte Multiple Write
*
* R0: Write address in VDP RAM
* R1: MSB of R1 sent to VDP RAM
* R2: Number of bytes to write to VDP RAM
*
* R0 is modified, but can be restored with: ANDI R0,>3FFF
*
vsmw:
       movb  @r0lb,@vdpwa              ; Send low byte of VDP RAM write address
       ori  r0,>4000                   ; Set read/write bits 14 and 15 to write (01)
       movb r0,@vdpwa                  ; Send high byte of VDP RAM write address
vsmw_1:
       movb r1,*15                     ; Write byte to VDP RAM
       dec  r2                         ; Byte counter
       jne  vsmw_1
       rt
*// vsmw

*********************************************************************
*
* VDP Multiple Byte Read
*
* R0: Starting read address in VDP RAM
* R1: Starting write address in CPU RAM
* R2: Number of bytes to read from VDP RAM
*
* Modifies R0-R2
*
vmbr:
       movb  @r0lb,@vdpwa              ; Send low byte of VDP RAM write address
       andi r0,>3fff
       movb r0,@vdpwa                  ; Send high byte of VDP RAM write address
       li   r0,vdprd
vmbr_1:
       movb *r0,*r1+                   ; Read byte from VDP RAM
       dec  r2                         ; Byte counter
       jne  vmbr_1                     ; Check if finished
       rt
*// vmbr

*********************************************************************
*
* Wait for key press
*
wait_key:
       .proc
wait_key_1:
       bl   @check_quit
       bl   @any_key
       jne  wait_key_2
*       bl   @vsync
*       bl   @play_sound
       jmp  wait_key_1
*      Return
wait_key_2:
       .endproc
*// wait_key

*********************************************************************
*
* Check quit
*
check_quit:
       clr  r1                         ; Test column 0
       li   r12,>0024                  ; Address for column selection
       ldcr r1,3                       ; Select column
       li   r12,>0006                  ; Address to read rows
       stcr r1,8
       andi r1,>1100
       jeq  quit
*      Return
       rt
*      Quit
quit   clr  @>83c4                     ; Reset user ISR address
       blwp @>0000
*// check_quit

*********************************************************************
*
* Check key
*
* r0: Column in MSB: >0000 - >0700, Row in LSB: >0006 - >0014
*
*       Column   0      1    2    3    4    5     6       7
*     Row
*     >0006      =      .    ,    M    N    /    Fire    Fire
*     >0008    Space    L    K    J    H    ;    Left    Left
*     >000A    Enter    O    I    U    Y    P    Right   Right
*     >000C             9    8    7    6    0    Down    Down
*     >000E    Fctn     2    3    4    5    1    Up      Up
*     >0010    Shift    S    D    F    G    A
*     >0012    Ctrl     W    E    R    T    Q
*     >0014             X    C    V    B    Z
*
* On return NEQ means that the key is pressed
*
KEY_FI EQU  >0606
KEY_LF EQU  >0608
KEY_RG EQU  >060A
KEY_DN EQU  >060C
KEY_UP EQU  >060E
KEY_CM EQU  >0206
KEY_FS EQU  >0106
KEY_0  EQU  >050C
KEY_1  EQU  >050E
KEY_2  EQU  >010E
KEY_3  EQU  >020E
KEY_4  EQU  >030E
KEY_5  EQU  >040E
KEY_6  EQU  >040C
KEY_7  EQU  >030C
KEY_8  EQU  >020C
KEY_9  EQU  >010C
KEY_A  EQU  >0510
KEY_B  EQU  >0414
KEY_C  EQU  >0214
KEY_D  EQU  >0210
KEY_E  EQU  >0212
KEY_F  EQU  >0310
KEY_G  EQU  >0410
KEY_H  EQU  >0408
KEY_I  EQU  >020A
KEY_J  EQU  >0308
KEY_K  EQU  >0208
KEY_L  EQU  >0108
KEY_M  EQU  >0306
KEY_N  EQU  >0406
KEY_O  EQU  >010A
KEY_P  EQU  >050A
KEY_Q  EQU  >0512
KEY_R  EQU  >0312
KEY_S  EQU  >0110
KEY_T  EQU  >0412
KEY_U  EQU  >030A
KEY_V  EQU  >0314
KEY_W  EQU  >0112
KEY_X  EQU  >0114
KEY_Y  EQU  >040A
KEY_Z  EQU  >0514
KEY_SP EQU  >0008
KEY_EN EQU  >000A
KEY_FN EQU  >000E
KEY_SH EQU  >0010
KEY_CT EQU  >0012
JOY_FI EQU  >0606
JOY_LT EQU  >0608
JOY_RT EQU  >060A
JOY_DN EQU  >060C
JOY_UP EQU  >060E
*
check_key:
       li   r12,>0024                  ; CRU address of the column decoder
       ldcr r0,3                       ; Select column
       andi r0,>00ff
       mov  r0,r12                     ; Select row
       tb   0                          ; Test key, EQ if not pressed
       rt
*// check_key

*********************************************************************
*
* Resets EQ (neq) if any key is pressed
*
any_key:
*      Check Ctrl
       li   r0,KEY_SH                  ; Shift
       li   r12,>0024                  ; CRU address of the column decoder
       ldcr r0,3                       ; Select column
       andi r0,>00ff
       mov  r0,r12                     ; Select row
       tb   0                          ; Test key, EQ if not pressed
       jeq  any_key_0
       c    r0,r0                      ; Set eq
       jmp  any_key_4
*      Check all columns
any_key_0:
       li   r1,>0000                   ; Column
any_key_1:
       li   r12,>0024                  ; CRU address of the column decoder
       mov  r1,r0
       swpb r0
       ldcr r0,3                       ; Select column
       li   r12,0006                   ; Select row
       stcr r0,8
       seto r2
       cb   r0,r2                      ; If any bit is reset a key is pressed
       jne  any_key_2
       inc  r1
       ci   r1,8
       jne  any_key_1
       jmp  any_key_4                  ; eq ok
any_key_2:
       ci   r1,6
       jne  any_key_3                  ; neq ok
*       inc  @user_input_device         ; Still neq
       jmp  any_key_4
any_key_3:
*       clr  @user_input_device         ; Sets eq
       seto r0                         ; Reset eq
       jmp  any_key_4
any_key_4:
       rt
*// any_key

*********************************************************************
*
* Random number generator
*
rand:
       li   r0,28643                   ; A prime number to multiply by
       mpy  @rand_no,r0
       mov  r1,r0
       ai   r0,31873                   ; Add a prime number
       src  r0,7                       ; Shift to break odd/even pattern
       mov  r0,@rand_no
       rt
*// rand
