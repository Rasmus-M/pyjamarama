*********************************************************************
*
* Pyjamarama
* For the TI-99/4A home computer
*
* November 2018
* Rasmus Moustgaard <rasmus.moustgaard@gmail.com>
*
*********************************************************************

       def  main

**
* Assembly options
*
immunity:
       equ  0

**
* Constants
*

**
* Memory mapped addresses
*
vdpwd  equ  >8c00                      ; VDP write data
vdpwa  equ  >8c02                      ; VDP set read/write address
vdprd  equ  >8800                      ; VDP read data
vdpsta equ  >8802                      ; VDP status
sound  equ  >8400

**
* VDP memory map
*
ptrntb equ  >0000                      ; Pattern table base
sprptb equ  >1800                      ; Sprite pattern table base
colrtb equ  >2000                      ; Color table base
nametb equ  >3800                      ; Name table base
spratb equ  >3C00                      ; Sprite attribute table base 1

**
* Structures
*

**
* Scratch pad
*
pad    equ  >8300
wrksp  equ  pad                        ; Workspace
r0lb   equ  wrksp+1                    ; r0 low byte required for VDP routines
r1lb   equ  wrksp+3
r2lb   equ  wrksp+5
r3lb   equ  wrksp+7
stack  equ  pad+>20                    ; Stack (grows up)
padvar equ  stack+>10                  ; Start of pad variables
*
* PAD variables
*
wally_room_no:
       equ  padvar
bitmap_x:
       equ  wally_room_no+2
bitmap_y:
       equ  bitmap_x+2
pad_max:
       equ  bitmap_y+2

**
* Macros
*
       .defm proc
       mov  r11,*r10+
       .endm

       .defm endproc
       dect r10
       mov  *r10,r11
       b    *r11
       .endm

********************************************************************************
*
* Main program
*
       aorg >a000
main:
       limi 0                          ; Interrupts off
       lwpi wrksp                      ; Setup workspace
       li   r10,stack                  ; Setup stack pointer
       bl   @bitmap_mode
loop:
       jmp  loop


********************************************************************************
*
* Room draw
*
room_draw:
       .proc
       mov  @wally_room_no,r4          ; Get room number.
       sla  r4,1                       ; Work out address of room pointer.
       mov  @room_data(r4),r4          ; Get address to room description data.
       movb *r4,r0
       cb   r0,@byte_f5                ; Get first byte and test for drawing of walls etc.
       jne  room_draw_0
       bl   @draw_ceiling_wall_floor
room_draw_0:
       movb *r4+,r0
       cb   r0,@byte_ff
       jeq  room_draw_5
       cb   r0,@byte_f4
       jne  room_draw_2
       li   r3,tile_draw_flip
room_draw_1:
       mov  r3,@furniture_draw_tile+2  ; Modify code so that the furniture draw routine calls the function
                                       ; to draw normal or upside down tiles.
       jmp  room_draw_0
room_draw_2:
       cb   r0,@byte_f3
       jne  room_draw_3
       li   r3,tile_draw
       jmp  room_draw_1
room_draw_3:
       cb   r0,@byte_de
       jne  room_draw_4
       movb *r4+,r1                    ; Get address of action flag.
       movb *r4+,@r1lb
       movb *r1,r0                     ; Get action flag
       jeq  room_draw_5                ; If not set then handle action,
       jmp  room_draw_0                ; else continue onto next byte.
room_draw_4:
       movb *r4+,@r0lb                 ; Y position
       clr  r1
       movb *r4+,@r1lb                 ; Get index of furniture item.
       sla  r1,1
       mov  @furniture_table(r1),r1    ; Workout address of item string.
       bl   @furniture_draw
       jmp  room_draw_0
room_draw_5:
       mov  @wally_room_no,r3
       sla  r3,1                       ; x2
       a    @wally_room_no,r3          ; x3
       ai   r3,room_obj_slots
       clr  r0
       movb *r3+,@r0lb
       mov  r0,@bitmap_x
       movb *r3+,@r0lb
       ai   r0,>10
       mov  r0,@bitmap_y
       movb *r3,@r0lb
       ai   r0,>50
       bl   @bitmap_16_draw
       .endproc
*// room_draw

*********************************************************************************
*
* Draw furniture
*
* Input:
* r0 MSB: x position
* r0 LSB: y position
* r1b: Address of furniture item string
*
furniture_draw:
       .proc
furniture_draw_tile:
       bl   @tile_draw
       .endproc
*// furniture_draw

*********************************************************************************
*
* Draw ceiling, wall and floor
*
* Input:
*
draw_ceiling_wall_floor:
       .proc
       .endproc
*// draw_ceiling_wall_floor

*********************************************************************************
*
* Draw tile
*
* Input:
* r0 MSB: x position
* r0 LSB: y position
* tile number, color
*
tile_draw:
       .proc
       .endproc
*// tile_draw

*********************************************************************************
*
* Draw tile upside down
*
* Input:
* r0 MSB: x position
* r0 LSB: y position
* tile number, color
*
tile_draw_flip:
       .proc
       .endproc
*// tile_draw_flip

*********************************************************************************
*
* Draw 16x16 bitmap
*
* Input:
* r0: Index of bitmap to draw
* @bitmap_x: x coordinate
* @bitmap_y: y coordinate
*
bitmap_16_draw:
       .proc
       .endproc
*// bitmap_16_draw

*********************************************************************************
*
* Set full bitmap mode
*
bitmap_mode:
       .proc
       clr  r0
       li   r1,vregs2
       li   r2,8
bitmap_mode_1:
       movb *r1+,@r0lb
       bl   @vwtr                      ; Set register
       ai   r0,>0100
       dec  r2
       jne  bitmap_mode_1
*      Name table
       li   r0,nametb
       bl   @vwad
       clr  r1
       li   r2,>300
bitmap_mode_2:
       movb r1,@vdpwd
       ai   r1,>0100
       dec  r2
       jne  bitmap_mode_2
*      Sprite attributes
       li   r0,spratb
       li   r1,>d000
       bl   @vsbw
*      Return
       .endproc
*      VDP registers
vregs2:
       byte >02                        ; Graphics II mode
       byte >a2                        ; 16K, display off, interrupt enabled
       byte nametb/>400                ; Name table
       byte >ff                        ; Color table
       byte ptrntb/>800+>03            ; Pattern table
       byte spratb/>80                 ; Sprite attribute table
       byte sprptb/>800                ; Sprite pattern table
       byte >01                        ; Backdrop color
*// bitmap_mode

*********************************************************************
*
* VDP Write To Register
*
* R0 MSB: VDP register to write to
* R0 LSB: Value to write
*
vwtr:
       swpb r0
       movb r0,@vdpwa                  ; Send low byte (value) to write to VDP register
       swpb r0
       ori  r0,>8000                   ; Set up a VDP register write operation (10)
       movb r0,@vdpwa                  ; Send high byte (address) of VDP register
       b    *r11
*// vwtr

*********************************************************************
*
* VDP Set Write Address
*
* R0: Write address in VDP RAM
*
* R0 is modified, but can be restored with: ANDI R0,>3FFF
*
vwad:
       swpb r0
       movb r0,@vdpwa                  ; Send low byte of VDP RAM write address
       swpb r0
       ori  r0,>4000                   ; Set read/write bits 14 and 15 to write (01)
       movb r0,@vdpwa                  ; Send high byte of VDP RAM write address
       b    *r11
*// vwad

*********************************************************************
*
* VDP Single Byte Read
*
* R0   Read address in VDP RAM
* R1   MSB of R1 set to byte from VDP RAM
*
vsbr:
       swpb r0
       movb r0,@vdpwa                  ; Send low byte of VDP RAM write address
       swpb r0
       movb r0,@vdpwa                  ; Send high byte of VDP RAM write address
       movb @vdprd,r1                  ; Read byte from VDP RAM
       b    *r11
*// vsbr

*********************************************************************
*
* VDP Single Byte Write
*
* R0: Write address in VDP RAM
* R1: MSB of R1 sent to VDP RAM
*
* R0 is modified, but can be restored with: ANDI R0,>3FFF
*
vsbw:
       swpb r0
       movb r0,@vdpwa                  ; Send low byte of VDP RAM write address
       swpb r0
       ori  r0,>4000                   ; Set read/write bits 14 and 15 to write (01)
       movb r0,@vdpwa                  ; Send high byte of VDP RAM write address
       movb r1,@vdpwd                  ; Write byte to VDP RAM
       b    *r11
*// vsbw

***************************************************************************
*
* VDP Multiple Byte Read
*
* R0: Starting read address in VDP RAM
* R1: Starting write address in CPU RAM
* R2: Number of bytes to read from VDP RAM
*
* Modifies R0-R2
*
vmbr:
       swpb r0
       movb r0,@vdpwa                  ; Send low byte of VDP RAM write address
       swpb r0
       movb r0,@vdpwa                  ; Send high byte of VDP RAM write address
vmbr0:
       li   r0,vdprd
vmbr1:
       movb *r0,*r1+                   ; Read byte from VDP RAM
       dec  r2                         ; Byte counter
       jne  vmbr1                      ; Check if finished
       b    *r11
*// vmbr

*********************************************************************
*
* Fast CPU to VDP copy, replaces VMBW
*
* R0: Destination address
* R1: Source address
* R2: Number of bytes to copy
*
* Modifies r0-r3
*
vdpcp:
       mov  r11,*r10+                  ; Push return address onto the stack
       swpb r0
       movb r0,@vdpwa                  ; Send low byte of VDP RAM write address
       swpb r0
       ori  r0,>4000                   ; Set the two MSbits to 01 for write
       movb r0,@vdpwa                  ; Send high byte of VDP RAM write address
       li   r0,vdpwd
vdpcp0:
       mov  r2,r3
       srl  r3,3                       ; Number of groups of 8
       jeq  vdpcp2
vdpcp1:
       movb *r1+,*r0
       movb *r1+,*r0
       movb *r1+,*r0
       movb *r1+,*r0
       movb *r1+,*r0
       movb *r1+,*r0
       movb *r1+,*r0
       movb *r1+,*r0
       dec  r3
       jne  vdpcp1
       andi r2,>0007                   ; Isolate number of remaining bytes
       jeq  vdpcp3
vdpcp2:
       movb *r1+,*r0
       dec  r2
       jne  vdpcp2
vdpcp3:
       dect r10                        ; Pop return address off the stack
       mov  *r10,r11
       b    *r11
*// vdpcp

*********************************************************************
*
* Fast CPU to VDP write, replaces VSMW
*
* R0: Destination address
* R1: Byte to write in MSB
* R2: Number of bytes to copy
*
* Modifies r0-r3
*
vdpwr:
       swpb r0
       movb r0,@vdpwa                  ; Send low byte of VDP RAM write address
       swpb r0
       ori  r0,>4000                   ; Set the two MSbits to 01 for write
       movb r0,@vdpwa                  ; Send high byte of VDP RAM write address
       li   r0,vdpwd
       mov  r2,r3
       srl  r3,3                       ; Number of groups of 8
       jeq  vdpwr2
vdpwr1:
       movb r1,*r0
       movb r1,*r0
       movb r1,*r0
       movb r1,*r0
       movb r1,*r0
       movb r1,*r0
       movb r1,*r0
       movb r1,*r0
       dec  r3
       jne  vdpwr1
       andi r2,>0007                   ; Isolate number of remaining bytes
       jeq  vdpwr3
vdpwr2:
       movb r1, *r0
       dec  r2
       jne  vdpwr2
vdpwr3:
       b    *r11
*// vdpwr

*********************************************************************
*
* Data
*
byte_ff:
       byte >ff
byte_f5:
       byte >f5
byte_f4:
       byte >f4
byte_f3:
       byte >f3
byte_de:
       byte >de
       even

       copy "bmp-milk.a99"
       copy "bmp-objects.a99"
       copy "bmp-tiles.a99"
       copy "bmp-wally.a99"
       copy "furniture.a99"
       copy "rooms.a99"
       copy "room-object-slots.a99"

       end
