*********************************************************************
*
* Main handler for moving Wally around
*
wally_handler:
       .proc
       mov  @wally_y,r0                ; Get current position, shift to 1 cell across and 4 rows down. Under the feet of Wally.
       ab   @byte_08,@r0lb
       ab   @byte_20,r0
       bl   @get_attribute             ; Get the background colour at that point and store.
       movb r0,@wally_attr
       abs  @wally_char_aligned        ; See if Wally is aligned with the character cell row at current position.
       jne  wally_handler_0
       ai   r1,-32                     ; One row up
       movb *r1,@wally_attr_alt
       jmp  wally_handler_1
wally_handler_0:
       movb r0,@wally_attr_alt         ; Store this for both flags.
*      Check Wally's state
wally_handler_1:
       movb @is_arcade_mode,r0         ; See if game is in Arcade mode, which means no jumping or falling.
       jne  wally_handler_2
       movb @wally_jump_dir,r0         ; See if Wally is currently in a jump.
       jne  wally_jump_handler_entry
wally_handler_2:
       movb @wally_falling,r0	       ; See if Wally is falling.
       jne  wally_check_fall
       movb @wally_attr,r0             ; See if Wally is not on a platform and needs to start falling.
       cb   r0,@byte_attr_45           ; Cyan
       jeq  wally_handler_3
       cb   r0,@byte_attr_42           ; Red
       jeq  wally_handler_3
       movb @byte_01,@wally_falling
       jmp  wally_check_fall
*      Check user's input
wally_handler_3:
*      Jump
       abs @input_flag
       jeq  wally_handler_4
*      Joystick
       li   r0,JOY_FI
       bl   @check_key
       jne  wally_jump
       jmp  wally_handler_5
wally_handler_4:
*      Keyboard
       li   r0,KEY_SP
       bl   @check_key
       jne  wally_jump
wally_handler_5:
       movb @byte_00,@wally_dir
       abs  @input_flag
       jeq  wally_handler_6
       li   r0,JOY_RT
       bl   @check_key
       jne  wally_handler_7
       jmp  wally_handler_8
Wally_Handler_6:
       li   r0,KEY_D
       bl   @check_key
       jeq  wally_handler_8
Wally_Handler_7:
       li   r0,>0100
       movb r0,@wally_dir
       movb r0,@wally_last_dir
       b    @wally_move
Wally_Handler_8:
       abs  @input_flag
       jeq  wally_handler_9
       li   r0,JOY_LT
       bl   @check_key
       jne  wally_handler_10
       jmp  wally_handler_end
Wally_Handler_9:
       li   r0,KEY_S
       bl   @check_key
       jeq  wally_handler_end
Wally_Handler_10:
       li   r0,->0100
       movb r0,@wally_dir
       movb r0,@wally_last_dir
       b    @wally_move

*      Check to see if Wally is standing on solid ground
wally_check_fall:
       movb @wally_attr,r0
       cb   r0,@byte_attr_42           ; Red
       jeq  wally_check_attr_solid
       cb   r0,@byte_attr_45           ; Cyan
       jne  wally_check_fall_0
wally_check_attr_solid:
       mov  @wally_char_aligned,r0      See if Wally is aligned with a character cell.
       jne  wally_check_fall_0         ; If not then let him fall regardless of colour.
       movb @byte_00,@wally_falling
       jmp  wally_handler_end
wally_check_fall_0:
       ab   @byte_04,@wally_y
wally_handler_end:
       .endproc
**
* Subroutine: Wally Jump
*
wally_jump:
       mov  @is_arcade_mode,r0         ; Stop any jumping when in Arcade Mode
;      jne  wally_shoot_create         ; TODO
* This entry point is used by the routine at Demo.
wally_jump_demo_entry:
       bl   @energy_countdown
       movb @wally_dir,r0              ; Either use the current direction if moving...
       jne  wally_jump_0
       movb @wally_last_dir,r0         ; Or use the last direction if standing still...
       movb r0,@wally_dir
wally_jump_0:
       movb r0,@wally_jump_dir
       movb @byte_00,@wally_jump_count
* This entry point is used by the routines at Wally_Handler and Demo.
wally_jump_handler_entry:
       movb @wally_dir,r0              ; Check for jumping to the right.
       cb   r0,@byte_01
       jeq  wally_jump_5
* Jumping Left.
       movb @byte_00,@wally_head_turned
       clr  r0
       movb @wally_jump_count,@r0lb    ; Get translation for next frame in jump.
       mov  r0,r3
       sla  r3,1
       a    r0,r3
       ai   r3,wally_jump_table
       movb *r3+,@r1lb                 ; X offset.
       movb *r3+,r1                    ; Y offset.
       movb *r3,r2                     ; Sprite frame index.
       sb   @byte_01,r1
       jlt  wally_jump_2               ; See if jump direction is up or falling.
       movb @wally_attr,r0             ; If falling test to see if Wally lands on anything.
       cb   r0,@byte_attr_42
       jeq  wally_jump_1
       cb   r0,@byte_attr_45
       jne  wally_jump_2
wally_jump_1:
       mov  @wally_char_aligned,r0
       jne  wally_jump_2
;	   CALL Wally_Erase	               ; Wally is standing directly on a platform, skip any further movement.
       jmp  wally_jump_4
wally_jump_2:
;	   CALL Wally_Erase                ; Returns position
       mov  @wally_y,r0	               ; Translate X and Y for jump.
       ab   r1,r0
       sb   @r1lb,@r0lb
       cb   @r0lb,@byte_07
       jhe  wally_jump_3
       movb @byte_07,@r0lb             ; Stop Wally from going of edge of screen.
wally_jump_3:
       mov  r0,@wally_y                ; Update position.
wally_jump_4:
       ab   @byte_20,r2                ; Update sprite.
       movb r2,@wally_frame
       ab   @byte_01,@wally_jump_count ; Increase the counter and check for end of jump.
       movb @wally_jump_count,r0
       cb   r0,@byte_0c
       jne  wally_jump_left_end
       movb  @byte_00,@wally_dir       ; Jump has ended, reset the flags.
       movb  @byte_00,@wally_jump_dir
       bl   @wally_steps_incr
wally_jump_left_end:
       .endproc
* Jumping right.
wally_jump_5:
       movb @byte_00,@wally_head_turned
       clr  r0
       movb @wally_jump_count,@r0lb    ; Get translation for next frame in jump.
       mov  r0,r3
       sla  r3,1
       a    r0,r3
       ai   r3,wally_jump_table
       movb *r3+,@r1lb                 ; X offset.
       movb *r3+,r1                    ; Y offset.
       movb *r3,r2                     ; Sprite frame index.
       sb   @byte_01,r1
       jlt  wally_jump_7               ; See if jump direction is up or falling.
       movb @wally_attr,r0             ; If falling test to see if Wally lands on anything.
       cb   r0,@byte_attr_42
       jeq  wally_jump_6
       cb   r0,@byte_attr_45
       jne  wally_jump_7
wally_jump_6:
       mov  @wally_char_aligned,r0
       jne  wally_jump_7
;	   CALL Wally_Erase	               ; Wally is standing directly on a platform, skip any further movement.
       jmp  wally_jump_9
wally_jump_7:
;	   CALL Wally_Erase                ; Returns position
       mov  @wally_y,r0	               ; Translate X and Y for jump.
       ab   r1,r0
       ab   @r1lb,@r0lb
       cb   @r0lb,@byte_e9
       jl   wally_jump_8
       movb @byte_e9,@r0lb             ; Stop Wally from going of edge of screen.
wally_jump_8:
       mov  r0,@wally_y                ; Update position.
wally_jump_9:
       ab   @byte_30,r2                ; Update sprite.
       movb r2,@wally_frame
       ab   @byte_01,@wally_jump_count ; Increase the counter and check for end of jump.
       movb @wally_jump_count,r0
       cb   r0,@byte_0c
       jne  wally_jump_right_end
       movb @byte_00,@wally_dir       ; Jump has ended, reset the flags.
       movb @byte_00,@wally_jump_dir
       bl   @wally_steps_incr
wally_jump_right_end:
       .endproc
**
* Subroutine: Wally Move
*
wally_move:
       bl   @energy_countdown
       movb @wally_dir,r0
       cb   r0,@byte_01
       jeq  wally_move_right
*      Wally Move Left
wally_move_left:
       movb @wally_frame,r0
       bl   @wally_turn_head
       cb   r0,@byte_00
       jhe  wally_move_1
wally_move_0:
       movb @byte_00,@wally_head_turned ; Clear head turn flag (1)
       movb @byte_00,r0
       jmp  wally_move_2
wally_move_1:
       ab   @byte_02,r0
       cb   r0,@byte_10
       jhe  wally_move_0
wally_move_2:
       movb r0,@wally_frame            ; Store new frame.
       movb @wally_x,r0                ; Get x position
       sb   @byte_02,r0                ; Move Wally left
       cb   r0,@byte_07
       jhe  wally_move_3               ; Don't let him move off the left hand side of screen.
       movb @byte_07,r0
wally_move_3:
       movb r0,@wally_x
       jmp  wally_move_8
*      Wally Move Right.
wally_move_right:
       movb @wally_frame,r0
       bl   @wally_turn_head
       cb   r0,@byte_10
       jhe  wally_move_5
wally_move_4:
       movb @byte_00,@wally_head_turned ; Clear head turn flag (2)
       movb @byte_10,r0
       jmp  wally_move_6
wally_move_5:
       ab   @byte_02,r0
       cb   r0,@byte_20
       jhe  wally_move_4
wally_move_6:
       movb r0,@wally_frame            ; Store new frame.
       movb @wally_x,r0                ; Get x position
       ab   @byte_02,r0
       cb   r0,@byte_e9
       jl   wally_move_7
       movb  @byte_e9,r0
wally_move_7:
       movb r0,@wally_x
wally_move_8:
       .endproc
*// wally_handler

*********************************************************************
*
* Checks to see if Wally should turn his head towards the camera
*
* Input:
* r0: Current frame to test against
*
wally_turn_head:
       .proc
       .push r0
       cb   r0,@byte_00
       jeq  wally_turn_head_2
       cb   r0,@byte_10
       jeq  wally_turn_head_2
       cb   r0,@byte_0c
       jeq  wally_turn_head_1
       cb   r0,@byte_1c
       jeq  wally_turn_head_1
       movb @wally_head_countdown,r0  ; If counter is greater than zero, skip onto just counting down.
       jne  wally_turn_head_3
       jmp  wally_turn_head_4
wally_turn_head_1:
       movb @wally_head_countdown,r0  ; If counter is greater than zero, skip onto just counting down.
       jne  wally_turn_head_3
       movb r0,@wally_head_turned      ; Clear Wally's head turn flag(2).
       bl   @rand                      ; Set a random value (0 ~ 1F) into countdown.
       andi r0,>1f00
       movb r0,@wally_head_countdown
       jmp  wally_turn_head_4
wally_turn_head_2
       movb @wally_head_countdown,r0  ; If counter is greater than zero, skip onto just counting down.
       jne  wally_turn_head_3
       movb @byte_01,@wally_head_turned
       jmp  wally_turn_head_4
wally_turn_head_3:
       sb   @byte_01,r0
       movb r0,@wally_head_countdown
wally_turn_head_4:
       .pop r0
       .endproc
*// wally_turn_head

*********************************************************************
*
* Checks to see if wally has put a foot down, classing as one step.
*
wally_step_check:
       .proc
       movb @wally_frame,r0
       andi r0,7
       jeq  wally_step_check_0
       movb @byte_00,@wally_step_flag
       jmp  wally_step_check_1
wally_step_check_0:
       movb @wally_step_flag,r0
       jne  wally_step_check_1
       movb @byte_01,@wally_step_flag
       bl   @wally_steps_incr
wally_step_check_1:
       .endproc
*// wally_step_check

wally_steps_incr:
       inc  @steps_counter
       rt
*//

*********************************************************************
*
* Check for Wally's death.
*
wally_check_for_death:
       .proc
       movb @death_flag,r0
       jeq  wally_check_for_death_2
       bl   @wally_knocked_down
       li   r2,6
wally_check_for_death_1:
       bl   @animation_frame
       dec  r2
       jne  wally_check_for_death_1
       bl   @wally_erase
*      Animate Wally's Death
wally_death:
       equ  $
;BDC3	LD A,L	Get X position.
;BDC4	LD H,D	Get Y position of lower half.
;BDC5	SUB $08	Adjust X position to left of standing position.
;BDC7	JR NC,Wally_Death_0	Don't let it drop of the left hand of screen.
;BDC9	XOR A
;Wally_Death_0
;BDCA	CP $E0
;BDCC	JR C,Wally_Death_1
;BDCE	LD A,$E0	Don't let it drop of the right hand of screen.
;Wally_Death_1
;BDD0	LD L,A	Update X position for drawing.
;BDD1	LD (BitmapX),HL
;BDD4	LD A,$4D	Dead Wally graphic.
;BDD6	CALL Bitmap16Draw
;BDD9	LD A,L
;BDDA	ADD A,$10
;BDDC	LD (BitmapX),A
;BDDF	LD A,$4E
;BDE1	CALL Bitmap16Draw
;BDE4	LD B,$28	Wait for a little while, updating the room.
;Wally_Death_2
;BDE6	PUSH BC
;BDE7	PUSH HL
;BDE8	CALL Pause_Short
;BDEB	CALL Room_EventCaller
;BDEE	POP HL
;BDEF	POP BC
;BDF0	DJNZ Wally_Death_2
;Wally_Death_3	BDF2	PUSH HL	Now float lying down Wally graphic up the screen.
;BDF3	CALL Room_EventCaller	Update room.
;BDF6	CALL Pause_Short
;BDF9	POP HL
;BDFA	LD (BitmapX),HL	Draw Wally.
;BDFD	LD A,$4D
;BDFF	CALL Bitmap16Draw
;BE02	LD A,L
;BE03	ADD A,$10
;BE05	LD (BitmapX),A
;BE08	LD A,$4E
;BE0A	CALL Bitmap16Draw
;BE0D	DEC H
;BE0E	DEC H
;BE0F	LD A,H
;BE10	CP $30	End of animation, move onto to losing a life.
;BE12	JR C,Wally_Resurrect
;BE14	LD (BitmapX),HL	Erase Wally.
;BE17	LD A,$4D
;BE19	CALL Bitmap16Draw
;BE1C	LD A,L
;BE1D	ADD A,$10
;BE1F	LD (BitmapX),A
;BE22	LD A,$4E
;BE24	CALL Bitmap16Draw
;BE27	JR Wally_Death_3
wally_check_for_death_2:
       .endproc
*// wally_check_for_death

*********************************************************************
*
* Lose a life, end game or resurrect Wally.
*
wally_resurrect:
;BE29	XOR A	Reset the energy glass.
;BE2A	LD (MilkLevel),A
;BE2D	CALL Milk_DrawFull
;BE30	LD HL,WallyLives	Lose one life and update the scoreboard.
;BE33	DEC (HL)
;BE34	LD A,(HL)
;BE35	ADD A,A
;BE36	ADD A,A
;BE37	ADD A,A
;BE38	ADD A,A
;BE39	LD (BitmapX),A
;BE3C	LD A,$10
;BE3E	LD (BitmapY),A
;BE41	LD A,$4C
;BE43	CALL Bitmap16Draw
;BE46	LD A,(WallyLives)	No more lives, so display the losing screen.
;BE49	OR A
;BE4A	JP Z,Screen_YouLost
;BE4D	LD A,(Wally_RoomNo)	Get the resurrect position, within the room, for Wally.
;BE50	LD E,A
;BE51	LD D,$00
;BE53	LD HL,Wally_ResurectY
;BE56	ADD HL,DE
;BE57	LD A,(HL)
;BE58	LD HL,Wally_ResurectX
;BE5B	ADD HL,DE
;BE5C	LD L,(HL)
;BE5D	LD H,A
;BE5E	LD (BitmapX),HL
;BE61	LD A,$9F	Index for 'puff of smoke' image, drawn to bring back Wally from the dead.
;BE63	CALL Bitmap16Draw
;BE66	LD A,H
;BE67	ADD A,$10
;BE69	LD (BitmapY),A
;BE6C	LD A,$9F
;BE6E	CALL Bitmap16Draw
;BE71	CALL Pause_Short
;BE74	LD D,$9F	'puff of smoke' animation start index.
;BE76	LD B,$05	Number of frames.
;Wally_Resurrect_0
;BE78	LD (BitmapX),HL	Animate smoke.
;BE7B	LD A,D
;BE7C	CALL Bitmap16Draw
;BE7F	LD A,H
;BE80	ADD A,$10
;BE82	LD (BitmapY),A
;BE85	LD A,D
;BE86	CALL Bitmap16Draw
;BE89	INC D
;BE8A	LD (BitmapX),HL
;BE8D	LD A,D
;BE8E	CALL Bitmap16Draw
;BE91	LD A,H
;BE92	ADD A,$10
;BE94	LD (BitmapY),A
;BE97	LD A,D
;BE98	CALL Bitmap16Draw	Make sure the rest of the room is still animated.
;BE9B	PUSH HL
;BE9C	PUSH DE
;BE9D	PUSH BC
;BE9E	CALL Room_EventCaller
;BEA1	CALL Pause_Short
;BEA4	CALL Room_EventCaller
;BEA7	CALL Pause_Short
;BEAA	POP BC
;BEAB	POP DE
;BEAC	POP HL
;BEAD	DJNZ Wally_Resurrect_0
;BEAF	LD (Wally_X),HL	Make sure Wally is resurrected.
;BEB2	LD (BitmapX),HL
;BEB5	LD A,D
;BEB6	CALL Bitmap16Draw
;BEB9	LD A,H
;BEBA	ADD A,$10
;BEBC	LD (BitmapY),A
;BEBF	LD A,D
;BEC0	CALL Bitmap16Draw
;BEC3	LD SP,$0000
;BEC6	XOR A
;BEC7	LD (DeathFlag),A
;BECA	CALL Wally_Reset
;BECD	CALL Wally_Draw
;BED0	LD A,(Wally_RoomNo)	For all the normal rooms...
;BED3	CP $1E
;BED5	JP C,GameLoop
;BED8	CALL Invaders_Init_YPos	For the special arcade room...
;BEDB	CALL Invaders_Init
;BEDE	JP Invaders_Loop
*// wally_resurrect

*********************************************************************
*
* Checks to see if Wally has walked away from an object slot if just pick up and object.
*
wally_test_obj_slots:
       .proc
       movb @obj_event_pause,r0        ; See if Wally has just picked up.
       jeq  wally_test_obj_slot_0
       mov  @wally_room_no,r3          ; If he has, see if he has now walked away from the object position.
       sla  r3,1                       ; x2
       a    @wally_room_no,r3          ; x3
       ai   r3,room_obj_slots
       movb *r3,r0
       sb   @wally_x,r0
       sb   @byte_06,r0
       cb   r0,@byte_f4
       jhe  wally_test_obj_slot_0
       movb @byte_00,@obj_event_pause
wally_test_obj_slot_0:
       .endproc
*// wally_test_obj_slots

*********************************************************************
*
* Updates the percentage score.
*
wally_percent_update:
       li   r0,>0100
       mov  @wally_room_no,r1          ; Mark room as visited
       movb r0,@rooms_visited_table(r1)
       mov  @pocket_1,r1               ; Make the first object being carried for percentage score.
       movb r0,@object_found_table(r1)
       mov  @pocket_2,r1               ; Make the first object being carried for percentage score.
       movb r0,@object_found_table(r1)
       rt
*// wally_percent_update

*********************************************************************
*
* Calls the event for the current room
*
room_event_caller:
       .proc
       mov  @wally_room_no,r1          ; Calculate address of jump vector (room*2) + vectors.
       sla  r1,1
       mov  @room_update_vectors(r1),r1
       bl   *r1
       .endproc
*// room_event_caller

*********************************************************************
*
* Check for SHIFT + BREAK to exit current game.
*
game_exit_check:
       .proc
       bl   @check_quit
       .endproc
*// game_exit_check

*********************************************************************
*
* Check for food pickup by Wally.
*
food_check_pickup:
       .proc
       mov  @food_active_ptr,r1        ; Get pointer to first active food.
       movb @wally_room_no+1,r0
       cb   r0,*r1                     ; See if is same room as Wally, returning if not.
       jeq  food_check_pickup_0
       ai   r1,>0016
       cb   r0,*r1                     ; If not, check for active food B.
       jeq  food_check_pickup_0
       jmp  food_check_pickup_end
*      Food found
food_check_pickup_0:
       inc  r1
       movb @wally_x,r0                ; Check to see if Wally is on the same X plane as the food.
       sb   *r1,r0
       sb   @byte_01,r0
       cb   r0,@byte_fe
       jl   food_check_pickup_end
       cb   @wally_y,@byte_98          ; Make sure he is also on the same Y position, which is fixed to $98.
       jne  food_check_pickup_end
       movb *r1+,@bitmap_x+1           ; Get the X position again and set for drawing.
       movb @byte_a8,@bitmap_y+1
*      Update bitmap
       clr  r0
       movb *r1,@r0lb                  ; Get the bitmap index.
       bl   @bitmap_16_erase
*      Update pointer
       mov  @food_active_ptr,r1        ; Set the next food in line as active, to replace the one just eaten.
       ai   r1,3
       cb   *r1,@byte_ff               ; Check for end of group, if so wrap around to start of table again.
       jne  food_check_pickup_1
       li   r1,food_table
food_check_pickup_1:
       mov  r1,@food_active_ptr        ; Store address for next time.
       li   r0,10
       bl   @milk_increase_by_amount
food_check_pickup_end:
       .endproc
*// food_check_pickup

*********************************************************************
*
* Checks the current room's logic and acts on anything that is 'true'.
*
room_test_events:
       .proc
       mov  @wally_room_no,r4          ; Gets the address of the room data, from the table of address based on the current room index number.
       sla r4,1
       mov  @table_room_logic_ptr(r4),r4
room_test_events_next_cmd:
       movb *r4+,r0
       cb   r0,@byte_ff                ; END
       jeq  room_test_events_end
       cb   r0,@byte_fd                ; THEN
       jeq  room_test_events_then
*      Perform test (IF)
       clr  r1                         ; Get address of function
       movb r0,@r1lb
       sla  r1,1
       mov  @table_test_func_ptrs(r1),r1
       b    *r1                        ; Jump to test function
*      Endif
room_test_events_endif:
       movb *r4+,r0                    ; Skip bytes until
       cb   r0,@byte_fe                ; ENDIF
       jeq  room_test_events_next_cmd
       jmp  room_test_events_endif
*      Then
room_test_events_then:
       movb *r4+,r0
       cb   r0,@byte_fe                ; Nothing to do?
       jeq  room_test_events_next_cmd
*      Perform action
       clr  r1                         ; Get address of action
       movb r0,@r1lb
       sla  r1,1
       mov  @table_action_func_ptrs(r1),r1
       b    *r1                        ; Jump to action
room_test_events_end:
       .endproc
*// room_test_events
