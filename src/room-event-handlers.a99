room_update_vectors:
       equ  $
LE62B  data update_room_00  
LE62D  data update_room_01  
LE62F  data update_room_02  
LE631  data update_room_03  
LE633  data update_room_04  
LE635  data update_room_05  
LE637  data update_room_06  
LE639  data update_room_07  
LE63B  data update_room_08  
LE63D  data update_room_09  
LE63F  data update_room_0A  
LE641  data update_room_0B  
LE643  data update_room_0C  
LE645  data update_room_0D  
LE647  data update_room_0E  
LE649  data update_room_0F  
LE64B  data update_room_10  
LE64D  data update_room_11  
LE64F  data update_room_12  
LE651  data update_room_13  
LE653  data update_room_14  
LE655  data update_room_15  
LE657  data update_room_16  
LE659  data update_room_17  
LE65B  data update_room_18  
LE65D  data update_room_19  
LE65F  data update_room_1a  
LE661  data update_room_1b  
LE663  data update_room_1c  
LE665  data update_room_1d  
LE667  data update_room_1e  
LE669  data update_room_1e  
LE66B  data update_room_1e  
LE66D  data update_room_1e  
LE66F  data update_room_1e  
LE671  data update_room_1e  
LE673  data update_room_1e  
LE675  data update_room_1e

update_room_00:
       .proc
LE677  bl @update_rolling_rock
LE67A  .endproc  

update_room_01:
       .proc
LE67B  bl @update_roll_ball
LE67E  .endproc  

update_room_02:
       .proc
LE67F  bl @handler_angels
LE682  bl @handler_food
LE685  bl @handler_spooky_hand
LE688  .endproc  

update_room_03:
       .proc
LE689  bl @handler_chickens
LE68C  .endproc  

update_room_04:
       .proc
LE68D  bl @handler_darts
LE690  .endproc  

update_room_05:
       .proc
LE691  bl @handler_bouncing_axe
LE694  .endproc  

update_room_06:
       .proc
LE695  bl @handler_savage_plant
LE698  .endproc  

update_room_07:
       .proc
LE699  bl @update_roll_ball
LE69C  .endproc  

update_room_08:
       .proc
LE69D  bl @handler_darts
LE6A0  .endproc  

update_room_09:
       .proc
LE6A1  bl @handler_food
LE6A4  bl @handler_balloon_help
LE6A7  bl @handler_spooky_hand
LE6AA  .endproc  

update_room_0A:
       .proc
LE6AB  bl @handler_bouncing_axe
LE6AE  .endproc  

update_room_0B:
       .proc
LE6AF  bl @handler_angels
LE6B2  .endproc  

update_room_0C:
       .proc
LE6B3  bl @handler_angels
LE6B6  bl @handler_spooky_hand
LE6B9  .endproc  

update_room_0D:
       .proc
LE6BA  bl @handler_spooky_hand
LE6BD  .endproc  

update_room_0E:
       .proc
LE6BE  bl @handler_angels
LE6C1  .endproc  

update_room_0F:
       .proc
LE6C2  bl @handler_food
LE6C5  bl @handler_books
LE6C8  .endproc  

update_room_10:
       .proc
LE6C9  bl @handler_moving_floor
LE6CC  bl @animate_moving_floor
LE6CF  bl @handler_spooky_hand
LE6D2  .endproc  

update_room_11:
       .proc
LE6D3  bl @handler_food
LE6D6  bl @handler_angels
LE6D9  .endproc  

update_room_12:
       .proc
LE6DA  bl @handler_bouncing_axe
LE6DD  .endproc  

update_room_13:
       .proc
LE6DE  bl @handler_darts
LE6E1  .endproc  

update_room_14:
       .proc
LE6E2  bl @handler_spooky_hand
LE6E5  .endproc  

update_room_15:
       .proc
LE6E6  bl @handler_food
LE6E9  bl @handler_bouncing_axe
LE6EC  .endproc  

update_room_16:
       .proc
LE6ED  bl @handler_ghosts
LE6F0  .endproc  

update_room_17:
       .proc
LE6F1  bl @handler_ghosts
LE6F4  bl @handler_food
LE6F7  .endproc  

update_room_18:
       .proc
LE6F8  bl @handler_spooky_hand
LE6FB  .endproc  

update_room_19:
       .proc
LE6FC  bl @handler_invaders
LE6FF  bl @Pause_Short  
LE702  bl @Pause_Short  
LE705  .endproc  

update_room_1a:
       .proc
LE706  bl @handler_food
LE709  bl @handler_three_ton
LE70C  .endproc  

update_room_1b:
       .proc
LE70D  bl @handler_three_ton
LE710  bl @handler_spooky_hand
LE713  .endproc  

update_room_1c:
       .proc
LE714  bl @handler_falling_blocks
LE717  bl @handler_fire
LE71A  .endproc  

update_room_1d:
       .proc
LE71B  bl @handler_bouncing_axe
LE71E  bl @handler_mag_lock
LE721  bl @handler_mag_lock
LE724  bl @handler_mag_lock
LE727  bl @handler_mag_lock
LE72A  bl @handler_mag_lock
LE72D  .endproc  

update_room_1e:
       .proc
LE72E  bl @Inv_Update
LE731  bl @Inv_Update  
LE734  bl @Inv_Update  
LE737  bl @Inv_Update  
LE73A  bl @Inv_Update  
LE73D  bl @Inv_Update  
LE740  bl @Arcade_UpdateExplosions  
LE743  bl @Inv_BulletUpdate  
LE746  bl @Arcade_UpdateBombs  
LE749  .endproc  

*********************************************************************
*
* Handler for rolling tock
*
update_rolling_rock:
       .proc
       mov  @room_0_rock_count,r0      ; Check and update countdown.
       jeq  update_rolling_rock_0
       dec  r0
       mov  r0,@room_0_rock_count
       jmp  update_rolling_rock_2      ; Do nothing if not zero yet.
update_rolling_rock_0:
       li   r0,>0026                   ; Number of times to move and draw rock.
       mov  r0,@room_0_update_count
update_rolling_rock_1:
       bl   @vsync
       li   r6,>0e00                   ; Y position of rock.
       movb @flag_rolling_rock,@r6lb   ; Use flag as X position of rock.
       bl   @rolling_rock_draw
       ab   @byte_01,@flag_rolling_rock         ; Move position for next frame.
       movb @wally_x,r0
       srl  r0,3
       cb   r0,@flag_rolling_rock
       jhe  update_rolling_rock_3
       bl   @wally_erase
update_rolling_rock_3:
       dec  @room_0_update_count
       jne  update_rolling_rock_1
       li   r0,>001c
       mov  r0,@wally_room_no
       clr  r0
       movb r0,@rolling_rock_draw
       movb r0,@flag_baddy_init
       movb @byte_01,@death_flag
       li   r0,>00c8
       mov  r0,@room_0_rock_count
       bl   @screen_clear_room
       bl   @room_draw
       bl   @wally_resurrect
update_rolling_rock_2:
       .endproc

rolling_rock_draw:
       .proc
       li   r7,8                       ; Width of rock in characters.
       li   r0,roll_rock_tiles
       mov  r0,@tile_start_ptr         ; Set draw to use the tiles for the rolling rock.
       li   r5,roll_rock_furniture     ; The furniture string for the rock.
rolling_rock_draw_0:
       li   r8,7                       ; Height of rock in characters.
rolling_rock_draw_1:
       cb   @r6lb,@byte_20             ; Check for edge of screen
       jhe  rolling_rock_draw_2
       movb *r5+,r0                    ; Tile no
       mov  r6,r1                      ; Position
       li   r2,attr_45                 ; Colour rock cyan.
       bl   @tile_draw
rolling_rock_draw_2:
       ab   @byte_01,r6                ; Next tile position down.
       dec  r8
       jne  rolling_rock_draw_1
       sb   @byte_01,@r6lb             ; Next column to the left!
       sb   @byte_07,r6                ; Back to top
       dec  r7
       jne  rolling_rock_draw_0
       .endproc

room_0_rock_count:
       data >00c8
room_0_update_count:
       data >00c8

*// update_rolling_rock

*********************************************************************
*
* Handler for the rolling ball
*
update_roll_ball:
       .proc
       movb @flag_baddy_init,r0
       jne  update_roll_ball_0
       movb @byte_01,@flag_baddy_init
       bl   @allocate_sprite
       mov  r0,@roll_ball_sprite
       mov  r0,r4
       li   r1,>3008
       mov  r1,*r4+                    ; Set position
       li   r0,>008d                   ; Pattern
       mov  r0,@roll_ball_frame
       bl   @get_sprite_pattern
       movb r1,*r4+
       movb @byte_0b,*r4               ; Color
       jmp  update_roll_ball_4
update_roll_ball_0:
       mov  @roll_ball_sprite,r4
       mov  *r4,r0                     ; Get position
       mov  @roll_ball_frame,r1
       cb   @r0lb,@byte_b0             ; At end of railing?
       jne  update_roll_ball_3         ; Jump if not
       ab   @byte_02,r0                ; Move down
       cb   r0,@byte_aa
       jl   update_roll_ball_1
       li   r0,>3008
update_roll_ball_1:
       mov  r0,*r4                     ; Store position
*      Animate
       .ifeq slow_animations,1
       mov  @frame,r0
       andi r0,animation_speed-1
       jne  update_roll_ball_2
       .else
       andi r0,>0002
       jne  update_roll_ball_2
       .endif
       inc  r1                         ; Animate
       ci   r1,>0090
       jne  update_roll_ball_2
       li   r1,>008d
update_roll_ball_2:
       mov  r1,@roll_ball_frame
       mov  r1,r0
       bl   @get_sprite_pattern
       movb r1,@sprite_pattern(r4)     ; Store pattern
       li   r0,10
       mov  *r4,r1
       bl   @wally_hit_test
       jmp  update_roll_ball_4
update_roll_ball_3:
       mov  r0,r2
       ab   @byte_02,@r0lb             ; Move right
       cb   @r2lb,@byte_1a
       jl   update_roll_ball_1
       ab   @byte_01,r0                ; Move slanted
       jmp  update_roll_ball_1
update_roll_ball_4:
       .endproc

roll_ball_sprite
       data 0
roll_ball_frame:
       data 0

*// update_roll_ball

*********************************************************************
*
* Handler for 'angels'
*
handler_angels:
       .proc
       movb @flag_baddy_init,r0        ; See if angels have been intialised.
       jne  handler_angels_0
*      Initialize
       movb @byte_01,@flag_baddy_init  ; Set as initialised.
       li   r0,>0002
       mov  r0,@angel1_direction       ; Set directions all the same.
       mov  r0,@angel2_direction
       mov  r0,@angel3_direction
       li   r0,>0093
       mov  r0,@angel_frame
       bl   @get_sprite_pattern
       li   r3,>0004                   ; Color
       movb r1,r3                      ; Pattern
       bl   @allocate_sprite           ; Set positions and draw each angel.
       mov  r0,@angel1_sprite
       li   r1,>3278
       mov  r1,*r0+
       mov  r3,*r0
       bl   @allocate_sprite
       mov  r0,@angel2_sprite
       li   r1,>6438
       mov  r1,*r0+
       mov  r3,*r0
       bl   @allocate_sprite
       mov  r0,@angel3_sprite
       li   r1,>50b8
       mov  r1,*r0+
       mov  r3,*r0
       jmp  handler_angels_end
* Update
handler_angels_0:
       mov  @angel_frame,r0            ; Get bitmap frame for all angels.
       .ifeq slow_animations,1
       mov  @frame,r1
       andi r1,animation_speed-1
       jne  handler_angels_1
       .endif
       inc  r0                         ; Update to next frame.
       ci   r0,>0099                   ; Check to see if frame needs to loop around.
       jne  handler_angels_1
       li   r0,>0093
handler_angels_1:
       mov  r0,@angel_frame
       bl   @get_sprite_pattern
       mov  r1,r6
handler_angels_5:
       li   r7,angel1_sprite           ; Point index to first angel.
       li   r8,3                       ; Number of angels to update.
handler_angels_2:
       mov  *r7+,r4                    ; Get sprite
       movb r6,@sprite_pattern(r4)
       ab   @1(r7),*r4                 ; Add velocity to y position
       cb   *r4,@byte_aa               ; See if at bottom of screen.
       jhe  handler_angels_3
       cb   *r4,@byte_30               ; See if at top of screen.
       jh   handler_angels_4
handler_angels_3:
       neg  *r7
handler_angels_4:
       li   r0,4                       ; Amount of energy loss if angel hits wally.
       mov  *r4,r1
       bl   @wally_hit_test
       inct r7
       dec  r8
       jne  handler_angels_2
handler_angels_end:
       .endproc

angel1_sprite:                         ; Sprite pointer
       data >0000
angel1_direction:                      ; Direction / Velocity of sprite.
       data >0002
angel2_sprite:
       data >0000
angel2_direction:
       data >0002
angel3_sprite:
       data >0000
angel3_direction:
       data >0002
angel_frame:                           ; Bitmap index. (93 ~ 98)
       data >0093

*// handler_angels

*********************************************************************
*
* Food handler
*
handler_food:
       .proc
       movb @flag_food_drawn,r0
       jne  handler_food_1
       movb @byte_01,@flag_food_drawn
       mov  @food_active_ptr,r1        ; Get info of currently active food.
       movb @wally_room_no+1,r0
       cb   r0,*r1                     ; See if is same room as Wally, returning if not.
       jeq  handler_food_0
       ai   r1,>0016
       cb   r0,*r1
       jne  handler_food_1
handler_food_0:
       inc  r1                         ; Get X position of food.
       movb *r1+,@bitmap_x+1
       li   r0,>00a8
       mov r0,@bitmap_y
       clr  r0
       movb *r1,@r0lb                  ; Get bitmap to display.
       bl   @bitmap_16_draw
handler_food_1:
       .endproc
*// handler_food

*********************************************************************
*
* Hendler for spooky hand
*
handler_spooky_hand:
       .proc
       mov  @spooky_hand_countdown,r0  ; Check count down, animating hand if already zero.
       jeq  handler_spooky_hand_update
       dec  @spooky_hand_countdown
       jne  handler_spooky_hand_end
       mov  @wally_room_no,r0          ; Get data for current room with a spooky hand. (Assumes this routine is only called by rooms that match.)
       swpb r0
       li   r3,spooky_hand_pos_table
handler_spooky_hand_0:
       cb   *r3+,r0
       jeq  handler_spooky_hand_1
       inct r3
       jmp  handler_spooky_hand_0
handler_spooky_hand_1:
       bl   @allocate_sprite           ; r0 contains address of sprite
       mov  r0,r4
       movb *r3+,@sprite_x(r4)         ; x
       movb *r3,*r4                    ; y
       li   r0,>00ad
       mov  r0,@spooky_hand_frame
       bl   @get_sprite_pattern
       movb r1,@sprite_pattern(r4)
       movb @byte_09,@sprite_color(r4)
       mov  r4,@spooky_hand_sprite
       jmp  handler_spooky_hand_end
* Update spooky hand for animation.
handler_spooky_hand_update:
* Check delay for a frame, exit if not ready to update.
       dec  @spooky_hand_frame_delay
       jne  handler_spooky_hand_end
       .ifeq slow_animations,1
       li   r0,animation_speed         ; Set frame delay
       .else
       li   r0,>0003                   ; Set frame delay as on Spectrum
       .endif
       mov  r0,@spooky_hand_frame_delay
       mov  @spooky_hand_sprite,r4
       mov  @spooky_hand_frame,r0
       inc  r0                         ; Next frame
       ci   r0,>00b3                   ; Check for end of animation, restarting countdown if end reached.
       jeq  handler_spooky_hand_2
       mov  r0,@spooky_hand_frame
       bl   @get_sprite_pattern
       movb r1,@sprite_pattern(r4)
       li   r0,2
       mov  *r4,r1
       bl   @wally_hit_test
       jmp  handler_spooky_hand_end
handler_spooky_hand_2:
       li   r0,>32
       mov  r0,@spooky_hand_countdown
       mov  r4,r0
       bl   @deallocate_sprite
handler_spooky_hand_end:
       .endproc

spooky_hand_countdown:
       data >0030                      ; Spooky Hand countdown. When zero reached hand appears out of ground.
spooky_hand_pos_table:
       byte >02,>68,>A8                ; Room and position of each spooky hand.
       byte >09,>40,>A8
       byte >0D,>60,>A8
       byte >10,>A0,>A8
       byte >14,>A8,>A8
       byte >18,>88,>78
       byte >1B,>20,>90
       byte >0C,>D8,>88
spooky_hand_frame:
       data >0000                      ; Index of current spooky hand bitmap.
spooky_hand_frame_delay:
       data >0004
spooky_hand_sprite:
       data >0000

*// handler_spooky_hand

*********************************************************************
*
* Handler for cooked chickens
*
handler_chickens:
       .proc
       movb @flag_baddy_init,r0
       jne  handler_chickens_1
       movb @byte_01,@flag_baddy_init
       li   r0,>007b
       mov  r0,@chicken_frame
       bl   @get_sprite_pattern
       mov  r1,r3
       movb @byte_06,@r3lb
       bl   @allocate_sprite
       mov  r0,@chicken_sprite_1
       li   r1,>8088
       mov  r1,*r0+
       mov  r3,*r0
       bl   @allocate_sprite
       mov  r0,@chicken_sprite_2
       li   r1,>a8a8
       mov  r1,*r0+
       mov  r3,*r0
       jmp handler_chickens_9
handler_chickens_1:
       mov  @chicken_frame,r0
       .ifeq slow_animations,1
       mov  @frame,r1
       andi r1,animation_speed-1
       jne  handler_chickens_2
       .endif
       inc  r0
       ci   r0,>007f
       jne  handler_chickens_2
       li   r0,>007b
handler_chickens_2:
       mov  r0,@chicken_frame
       bl   @get_sprite_pattern
       movb r1,r9
handler_chickens_3:
       li   r6,2
       li   r7,chicken_sprite_1
handler_chickens_4:
       mov  *r7+,r8
       movb r9,@sprite_pattern(r8)
       li   r0,1
       mov  *r8,r1
       bl   @wally_hit_test
       mov  *r8,r1                     ; Get y and x
       cb   r1,@byte_80                ; Is chicken on table?
       jne  handler_chickens_5         ; Jump if not
       sb   @byte_02,@r1lb             ; Move left
       cb   @r1lb,@byte_78             ; Reached edge of table?
       jne  handler_chickens_8         ; Jump if not
       movb @byte_82,r1                ; Start the drop
       jmp  handler_chickens_8         ; Next chicken
*      Not on table
handler_chickens_5:
       cb   r1,@byte_a8                ; On the floor?
       jeq  handler_chickens_6
*      Dropping to the floor
       ab   @byte_02,r1                ; Move down
       jmp  handler_chickens_8         ; Next chicken
*      On floor
handler_chickens_6:
       ci   r6,1
       jeq  handler_chickens_7
*      Move left
       sb   @byte_02,@r1lb             ; Move left
       cb   @r1lb,@byte_08
       jne  handler_chickens_8
       li   r1,>80b4
       jmp  handler_chickens_8
*      Move right
handler_chickens_7:
       ab   @byte_02,@r1lb             ; Move right
       cb   @r1lb,@byte_e8
       jne  handler_chickens_8
       li   r1,>80b4
handler_chickens_8:
       mov  r1,*r8                     ; Write y and x
       dec  r6
       jne  handler_chickens_4
handler_chickens_9:
       .endproc

chicken_frame:
       data >007b                       Index of chicken bitmap
chicken_sprite_1:
       data >0000
chicken_sprite_2:
       data >0000

*// handler_chickens

*********************************************************************
*
* Handler for darts
*
handler_darts:
       .proc
       movb @flag_baddy_init,r0        ; See if baddies need initializing.
       jne  handler_darts_1
       movb @byte_01,@flag_baddy_init
       li   r0,>0090
       mov  r0,@dart_frame
       bl   @get_sprite_pattern
       mov  r1,r3
       movb @byte_0d,@r3lb
       bl   @allocate_sprite
       mov  r0,@dart_sprite_1
       li   r1,>8808
       mov  r1,*r0+
       mov  r3,*r0
       bl   @allocate_sprite
       mov  r0,@dart_sprite_2
       li   r1,>a878
       mov  r1,*r0+
       mov  r3,*r0
       jmp handler_darts_6
handler_darts_1:
       mov  @dart_frame,r0
       .ifeq slow_animations,1
       mov  @frame,r1
       andi r1,animation_speed-1
       jne  handler_darts_2
       .endif
       inc  r0
       ci   r0,>0093
       jne  handler_darts_2
       li   r0,>0090
handler_darts_2:
       mov  r0,@dart_frame
       bl   @get_sprite_pattern
       movb r1,r9
handler_darts_3:
       li   r6,2                       ; Number of darts to draw.
       li   r7,dart_sprite_1
handler_darts_4:
       mov  *r7+,r8                    ; Get sprite pointer
       movb r9,@sprite_pattern(r8)     ; Update pattern
       mov  *r8,r1                     ; Get y and x
       ai   r1,2                       ; Move x position two to the right.
       cb   @r1lb,@byte_f0             ; Check for end of screen.
       jl   handler_darts_5
       movb @byte_08,@r1lb             ; Reset to left of screen if need be.
handler_darts_5:
       mov  r1,*r8                     ; Write y and x
       li   r0,1
       bl   @wally_hit_test
       dec  r6
       jne  handler_darts_4
handler_darts_6:
       .endproc

dart_sprite_1:
       data >0000
dart_sprite_2:
       data >0000
dart_frame:
       data >0090

*// handler_darts

*********************************************************************
*
* Handler for bouncing axe
*
handler_bouncing_axe:
       .proc
       movb @flag_baddy_init,r0        ; Has axe been intiialised yet?
       jne  handler_bouncing_axe_0
*      Initialise
       li   r0,>00b3
       mov  r0,@axe_frame
       bl   @get_sprite_pattern
       mov  r1,r3
       movb @byte_0e,@r3lb             ; Color
       bl   @allocate_sprite
       mov  r0,@axe_sprite
       li   r1,>3a64
       mov  r1,*r0+
       mov  r3,*r0
       li   r0,>0004
       mov  r0,@axe_velocity_y
       movb @byte_01,@flag_baddy_init
       jmp  handler_bouncing_axe_7
*      Update
handler_bouncing_axe_0:
       mov  @axe_sprite,r4
       mov  *r4,r0                     ; Get position
       ab   @axe_velocity_y+1,r0       ; Move Y in direction and speed of velocity.
       cb   r0,@byte_a8                ; Check for hitting the floor.
       jl   handler_bouncing_axe_2
handler_bouncing_axe_1:
       neg  @axe_velocity_y            ; Change direction of the Y velocity.
       jmp  handler_bouncing_axe_3
handler_bouncing_axe_2:
       cb   r0,@byte_38
       jl   handler_bouncing_axe_1
handler_bouncing_axe_3:
       inc  r0                         ; Move along X axis.
       cb   @r0lb,@byte_e8             ; Check for wrap around the room.
       jl   handler_bouncing_axe_4     ; Reset position to the left hand side.
       li   r0,>9808
       li   r1,-4
       mov  r1,@axe_velocity_y         ; Update velocity, in case it changed.
handler_bouncing_axe_4:
       mov  r0,*r4                     ; Update position.
       mov  @axe_frame,r0
       .ifeq slow_animations,1
       mov  @frame,r1
       andi r1,animation_speed-1
       jne  handler_bouncing_axe_6
       .else
       mov  *r4,r1
       andi r1,1                       ; Animate every even move.
       jne  handler_bouncing_axe_6
       .endif
       inc  r0
       ci   r0,>00bb
       jl   handler_bouncing_axe_6
handler_bouncing_axe_5:
       li   r0,>00b3                   ; Reset to first frame again.
handler_bouncing_axe_6:
       mov  r0,@axe_frame
       bl   @get_sprite_pattern
       movb r1,@sprite_pattern(r4)
       li   r0,5
       mov  *r4,r1
       bl   @wally_hit_test
handler_bouncing_axe_7:
       .endproc

axe_sprite:
       data >0000
axe_velocity_y
       data >0004                      ; Speed and direction of Axe's Y direction.
axe_frame:
       data >00b3

*// handler_bouncing_axe

*********************************************************************
*
* Handler for savage plant
*
handler_savage_plant:
       .proc
       movb @flag_baddy_init,r0
       jne  handler_savage_plant_0
       movb @byte_01,@flag_baddy_init
       li   r0,>0075
       mov  r0,@savage_plant_frame
       bl   @get_sprite_pattern
       mov  r1,r3
       movb @byte_0c,@r3lb
       bl   @allocate_sprite
       mov  r0,@savage_plant_sprite_1
       li   r1,>a848
       mov  r1,*r0+
       mov  r3,*r0
       bl   @allocate_sprite
       mov  r0,@savage_plant_sprite_2
       li   r1,>a8a8
       mov  r1,*r0+
       mov  r3,*r0
       jmp handler_savage_plant_3
handler_savage_plant_0:
       movb @flag_water_bucket,r0
       jeq  handler_savage_plant_1
       li   r0,>0010
       c    r0,@pocket_1
       jeq  handler_savage_plant_3
       c    r0,@pocket_2
       jeq  handler_savage_plant_3
       cb   @r0lb,@obj_slot_05_bmp
       jeq  handler_savage_plant_3
handler_savage_plant_1:
       mov  @savage_plant_frame,r0
       .ifeq slow_animations,1
       mov  @frame,r1
       andi r1,animation_speed-1
       jne  handler_savage_plant_2
       .endif
       inc  r0
       ci   r0,>007a
       jne  handler_savage_plant_2
       li   r0,>0075
handler_savage_plant_2:
       mov  r0,@savage_plant_frame
       bl   @get_sprite_pattern
       mov  @savage_plant_sprite_1,r4
       movb r1,@sprite_pattern(r4)
       mov  @savage_plant_sprite_2,r4
       movb r1,@sprite_pattern(r4)
       li   r0,8
       mov  @savage_plant_sprite_1,r4
       mov  *r4,r1
       bl   @wally_hit_test
       li   r0,8
       mov  @savage_plant_sprite_2,r4
       mov  *r4,r1
       bl   @wally_hit_test
handler_savage_plant_3:
       .endproc

savage_plant_frame:
       data >0075
savage_plant_sprite_1:
       data >0000
savage_plant_sprite_2:
       data >0000

*// handler_savage_plant

*********************************************************************
*
handler_balloon_help:
       .proc
;      TODO
       .endproc
*// handler_balloon_help

*********************************************************************
*
handler_books:
       .proc
;      TODO
       .endproc
*// handler_books

*********************************************************************
*
handler_moving_floor:
       .proc
       movb @death_flag,r0             ; Ignore if dead.
       jne  handler_moving_floor_2
       cb   @pocket_1+1,@byte_12       ; See if Wally is carrying the remote control. If he is don't update making it look like the floor has been stopped.
       jeq  handler_moving_floor_2
       cb   @pocket_2+1,@byte_12
       jeq  handler_moving_floor_2
       cb   @wally_y,@byte_91          ; If Wally is above the floor then don't update.
       jl   handler_moving_floor_2
       movb @wally_x,r0
       ab   @byte_02,r0
       cb   r0,@byte_e8
       jle  handler_moving_floor_1
       movb @byte_e8,r0
handler_moving_floor_1:
       movb r0,@wally_x
handler_moving_floor_2:
       .endproc

*********************************************************************
*
* Scrolls the top two layers of the floor, animating it like a travelator.
*
animate_moving_floor:
       .proc
       cb   @pocket_1+1,@byte_12
       jeq  animate_moving_floor_2
       cb   @pocket_2+1,@byte_12
       jeq  animate_moving_floor_2
       cb   @death_flag,@byte_01
       jeq  animate_moving_floor_2
       li   r0,>1700
       bl   @vsbr
       clr  r3
       movb r1,r3
       srl  r3,2
       socb @r3lb,r3
       clr  r4
       movb @vdprd,r4
       srl  r4,2
       socb @r4lb,r4
       li   r0,>1700+>4000
       li   r2,32
animate_moving_floor_1:
       movb @r0lb,@vdpwa
       movb r0,@vdpwa
       bl   @vwad
       movb r3,*r15
       movb r4,*r15
       ai   r0,8
       dec  r2
       jne  animate_moving_floor_1
animate_moving_floor_2:
       .endproc

*********************************************************************
*
* Handler for ghosts
*
handler_ghosts:
       .proc
;      TODO
       .endproc
*// handler_ghosts

*********************************************************************
*
* Handler for 3 ton weight
*
handler_three_ton:
       .proc
;      TODO
       .endproc
*// handler_three_ton

*********************************************************************
*
* Handler for falling blocks
*
handler_falling_blocks:
       .proc
;      TODO
       .endproc
*// handler_falling_blocks

*********************************************************************
*
* Handler for fire
*
handler_fire:
       .proc
;      TODO
       .endproc
*// handler_fire

*********************************************************************
*
* Handler for magnetic lock
*
handler_mag_lock:
       .proc
;      TODO
       .endproc

mag_lock_dir:
       data >0000

*// handler_mag_lock

*********************************************************************
*
* Handler for space invaders
*
handler_invaders:
       .proc
;      TODO
       .endproc
*// handler_invaders

*********************************************************************
*
Inv_Update:
       .proc
;      TODO
       .endproc

*********************************************************************
*
Arcade_UpdateExplosions:
       .proc
;      TODO
       .endproc

*********************************************************************
*
Inv_BulletUpdate:
       .proc
;      TODO
       .endproc

*********************************************************************
*
Arcade_UpdateBombs:
       .proc
;      TODO
       .endproc

*********************************************************************
*
Pause_Short:
       .proc
;      TODO
       .endproc
