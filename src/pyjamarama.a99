*********************************************************************
*
* Pyjamarama
* For the TI-99/4A home computer
*
* November 2018
* Rasmus Moustgaard <rasmus.moustgaard@gmail.com>
*
*********************************************************************

       def  main

**
* Assembly options
*
immunity:
       equ  0

**
* Constants
*

**
* Memory mapped addresses
*
vdpwd  equ  >8c00                      ; VDP write data
vdpwa  equ  >8c02                      ; VDP set read/write address
vdprd  equ  >8800                      ; VDP read data
vdpsta equ  >8802                      ; VDP status
sound  equ  >8400

**
* VDP memory map
*
ptrntb equ  >0000                      ; Pattern table base
sprptb equ  >1800                      ; Sprite pattern table base
colrtb equ  >2000                      ; Color table base
nametb equ  >3800                      ; Name table base
spratb equ  >3C00                      ; Sprite attribute table base 1

**
* Structures
*

**
* Scratch pad
*
pad    equ  >8300
wrksp  equ  pad                        ; Workspace
r0lb   equ  wrksp+1                    ; r0 low byte required for VDP routines
r1lb   equ  wrksp+3
r2lb   equ  wrksp+5
r3lb   equ  wrksp+7
r4lb   equ  wrksp+9
r5lb   equ  wrksp+11
r6lb   equ  wrksp+13
r7lb   equ  wrksp+15
r8lb   equ  wrksp+17
r9lb   equ  wrksp+19
stack  equ  pad+>20                    ; Stack (grows up)
padvar equ  stack+>10                  ; Start of pad variables
*
* PAD variables
*
wally_room_no:
       equ  padvar
bitmap_x:
       equ  wally_room_no+2
bitmap_y:
       equ  bitmap_x+2
tile_start_ptr:
       equ  bitmap_y+2
pad_max:
       equ  tile_start_ptr+2

**
* Macros
*
       .defm proc
       mov  r11,*r10+
       .endm

       .defm endproc
       dect r10
       mov  *r10,r11
       b    *r11
       .endm

********************************************************************************
*
* Main program
*
       aorg >a000
main:
       limi 0                          ; Interrupts off
       lwpi wrksp                      ; Setup workspace
       li   r10,stack                  ; Setup stack pointer
       bl   @bitmap_mode
       clr  @wally_room_no
       bl   @room_draw
loop:
       jmp  loop


********************************************************************************
*
* Room draw
*
room_draw:
       .proc
       mov  @wally_room_no,r4          ; Get room number.
       sla  r4,1                       ; Work out address of room pointer.
       mov  @room_data(r4),r4          ; Get address to room description data.
       movb *r4,r0
       cb   r0,@byte_f5                ; Get first byte and test for drawing of walls etc.
       jne  room_draw_0
       bl   @draw_ceiling_wall_floor
*      Draw furniture
room_draw_0:
       movb *r4+,r0
       cb   r0,@byte_ff
       jeq  room_draw_5
       cb   r0,@byte_f4
       jne  room_draw_2
       li   r3,tile_draw_flip
room_draw_1:
       mov  r3,@furniture_draw_tile_1+2 ; Modify code so that the furniture draw routine calls the function
       mov  r3,@furniture_draw_tile_2+2 ; to draw normal or upside down tiles.
       jmp  room_draw_0
room_draw_2:
       cb   r0,@byte_f3
       jne  room_draw_3
       li   r3,tile_draw
       jmp  room_draw_1
room_draw_3:
       cb   r0,@byte_de
       jne  room_draw_4
       movb *r4+,r1                    ; Get address of action flag.
       movb *r4+,@r1lb
       movb *r1,r0                     ; Get action flag
       jeq  room_draw_5                ; If not set then handle action,
       jmp  room_draw_0                ; else continue onto next byte.
room_draw_4:
       movb *r4+,@r0lb                 ; Y position (X in MSB)
       clr  r1
       movb *r4+,@r1lb                 ; Get index of furniture item.
       sla  r1,1
       mov  @furniture_table(r1),r1    ; Workout address of item string.
       bl   @furniture_draw
       jmp  room_draw_0
*      Draw object
room_draw_5:
       mov  @wally_room_no,r3
       sla  r3,1                       ; x2
       a    @wally_room_no,r3          ; x3
       ai   r3,room_obj_slots
       clr  r0
       movb *r3+,@r0lb
       mov  r0,@bitmap_x
       movb *r3+,@r0lb
       ai   r0,>10
       mov  r0,@bitmap_y
       movb *r3,@r0lb
       ai   r0,>50
       bl   @bitmap_16_draw
       .endproc
*// room_draw

*********************************************************************************
*
* Draw furniture
*
* Input:
* r0 MSB: x position
* r0 LSB: y position
* r1: Address of furniture item string
* r4: Room data pointer, do not change
*
* HL	Address of furniture string.
* DE	Position(Py, Px)
* must not change r4
*
furniture_draw:
       .proc
furniture_draw_6:
       mov  r1,r5                      ; Save address
       mov  r0,r6                      ; Save position
       movb *r5+,r0                    ; Get next byte in string.
       jgt  furniture_draw_4           ; Test for normal tile.
       jeq  furniture_draw_4
       cb   r0,@byte_fe                ; Test for END OF STRING value.
       jeq  furniture_draw_5
       cb   r0,@byte_fe                ; Test for code.
       jne  furniture_draw_0
       movb *r5+,r0                    ; Get colour.
       bl   @ti_color                  ; Convert to TI color
       mov  r5,r7                      ; Save color
       jmp  furniture_draw_6
furniture_draw_0:
       cb   r0,@byte_fc                ; Test for code.
       jne  furniture_draw_1
       ab   *r5+,r6                    ; Px += Sx
       ab   *r5+,@r6lb                 ; Py += Sy
       jmp  furniture_draw_6
furniture_draw_1:
       cb   r0,@byte_fb                ; Test for code.
       jne  furniture_draw_2
       movb *r5+,r0                    ; Get next two bytes holding new tile start address.
       movb *r5+,@r0lb
       mov  r0,@tile_start_ptr         ; TODO: adjust address
       jmp  furniture_draw_6
furniture_draw_2:
       clr  r8
       movb *r5+,@r8lb                 ; Get number of times to draw.
       movb *r5+,@r1lb                 ; Get tile(n) to draw.
furniture_draw_3:
       mov  r6,r1                      ; Position
       mov  r7,r2                      ; Color
furniture_draw_tile_1:
       bl   @tile_draw                 ; Draw tile.
       ab   @byte_01,r6                ; Px++
       dec  r8
       jne  furniture_draw_3
       jmp  furniture_draw_6
furniture_draw_4:
       mov  r6,r1                      ; Position
       mov  r7,r2                      ; Color
furniture_draw_tile_2:
       bl   @tile_draw
       dec  r8
       jmp  furniture_draw_6
furniture_draw_5:
       .endproc
*// furniture_draw

*********************************************************************************
*
* Draw ceiling, wall and floor
*
* Input:
* r4: Room data pointer, do not change
*
draw_ceiling_wall_floor:
       .proc
       .endproc
*// draw_ceiling_wall_floor

*********************************************************************************
*
* Draw tile
*
* Input:
* r0 MSB: Tile number
* r1 MSB: x position
* r1 LSB: y position
* r2 MSB: color
* r4: Room data pointer, do not change
* r5: Furniture pointer, do not change
* r6-r8: Do not change
*
tile_draw:
       .proc
       .endproc
*// tile_draw

*********************************************************************************
*
* Draw tile upside down
*
* Input:
* r0 MSB: Tile number
* r1 MSB: x position
* r1 LSB: y position
* r2 MSB: color
* r4: Room data pointer, do not change
* r5: Furniture pointer, do not change
* r6-r8: Do not change
*
tile_draw_flip:
       .proc
       .endproc
*// tile_draw_flip

*********************************************************************************
*
* Draw 16x16 bitmap
*
* Input:
* r0: Index of bitmap to draw
* @bitmap_x: x coordinate
* @bitmap_y: y coordinate
*
bitmap_16_draw:
       .proc
       .endproc
*// bitmap_16_draw

*********************************************************************************
*
* Get TI-99 color from ZX Spectrum color
*
* r0 MSB: Colour-byte FBPPPIII
*  - I - Ink colour (0-7)
*  - P - Paper colour (0-7)
*  - B - Bright (0-No, 1-Yes)
*  - F - Flash  (0-No, 1-Yes)
*
* Modifies r2-r3
* On return r1 MSB contains the TI color FFFFBBBB.
*
ti_color:
       clr  r1
*      Foreground
       mov  r0,r2
       andi r2,>0700                   ; Foreground bits
       mov  r0,r3
       andi r3,>4000                   ; Bright bit
       srl  r3,3
       soc  r3,r2
       swpb r2
       movb @tipal(r2),r1
       sla  r1,4
*      Background
       mov  r0,r2
       andi r2,>3800                   ; Background bits
       srl  r2,3
       soc  r3,r2
       swpb r2
       movb @tipal(r2),r3
       socb r3,r1
*      Flash
       andi r0,>8000
       jeq  !
       srl  r1,4
       andi r1,>0ff0
       socb @r1lb,r1
       rt

* Spectrum palette
* 0  Black,    1 D Blue,   2 D Red,     3 D Magenta
* 4  D Green,  5 D Cyan,   6 D Yellow,  7 Grey
* 8  Black,    9 Blue,    10 Red,      11 Magenta
* 12 Green,   13 Cyan,    14 Yellow,   15 White

* TI palette
* 0  Trans,    1 Black,    2 M Green,   3 L Green
* 4  D Blue,   5 L Blue,   6 D Red,     7 Cyan
* 8  M Red,    9 L Red,   10 D Yellow, 11 L Yellow
* 12 D Green, 13 Magenta, 14 Gray,     15 White

tipal  byte 1,4,6,13,12,7,10,14,1,5,8,13,2,7,11,15
* Not used: 3 L Green, 9 L Red
* Not available: D Cyan, D Magenta
*// ti_color

*********************************************************************************
*
* Set full bitmap mode
*
bitmap_mode:
       .proc
       clr  r0
       li   r1,vregs2
       li   r2,8
bitmap_mode_1:
       movb *r1+,@r0lb
       bl   @vwtr                      ; Set register
       ai   r0,>0100
       dec  r2
       jne  bitmap_mode_1
*      Name table
       li   r0,nametb
       bl   @vwad
       clr  r1
       li   r2,>300
bitmap_mode_2:
       movb r1,@vdpwd
       ai   r1,>0100
       dec  r2
       jne  bitmap_mode_2
*      Sprite attributes
       li   r0,spratb
       li   r1,>d000
       bl   @vsbw
*      Return
       .endproc
*      VDP registers
vregs2:
       byte >02                        ; Graphics II mode
       byte >a2                        ; 16K, display off, interrupt enabled
       byte nametb/>400                ; Name table
       byte >ff                        ; Color table
       byte ptrntb/>800+>03            ; Pattern table
       byte spratb/>80                 ; Sprite attribute table
       byte sprptb/>800                ; Sprite pattern table
       byte >01                        ; Backdrop color
*// bitmap_mode

*********************************************************************
*
* VDP Write To Register
*
* R0 MSB: VDP register to write to
* R0 LSB: Value to write
*
vwtr:
       swpb r0
       movb r0,@vdpwa                  ; Send low byte (value) to write to VDP register
       swpb r0
       ori  r0,>8000                   ; Set up a VDP register write operation (10)
       movb r0,@vdpwa                  ; Send high byte (address) of VDP register
       b    *r11
*// vwtr

*********************************************************************
*
* VDP Set Write Address
*
* R0: Write address in VDP RAM
*
* R0 is modified, but can be restored with: ANDI R0,>3FFF
*
vwad:
       swpb r0
       movb r0,@vdpwa                  ; Send low byte of VDP RAM write address
       swpb r0
       ori  r0,>4000                   ; Set read/write bits 14 and 15 to write (01)
       movb r0,@vdpwa                  ; Send high byte of VDP RAM write address
       b    *r11
*// vwad

*********************************************************************
*
* VDP Single Byte Read
*
* R0   Read address in VDP RAM
* R1   MSB of R1 set to byte from VDP RAM
*
vsbr:
       swpb r0
       movb r0,@vdpwa                  ; Send low byte of VDP RAM write address
       swpb r0
       movb r0,@vdpwa                  ; Send high byte of VDP RAM write address
       movb @vdprd,r1                  ; Read byte from VDP RAM
       b    *r11
*// vsbr

*********************************************************************
*
* VDP Single Byte Write
*
* R0: Write address in VDP RAM
* R1: MSB of R1 sent to VDP RAM
*
* R0 is modified, but can be restored with: ANDI R0,>3FFF
*
vsbw:
       swpb r0
       movb r0,@vdpwa                  ; Send low byte of VDP RAM write address
       swpb r0
       ori  r0,>4000                   ; Set read/write bits 14 and 15 to write (01)
       movb r0,@vdpwa                  ; Send high byte of VDP RAM write address
       movb r1,@vdpwd                  ; Write byte to VDP RAM
       b    *r11
*// vsbw

***************************************************************************
*
* VDP Multiple Byte Read
*
* R0: Starting read address in VDP RAM
* R1: Starting write address in CPU RAM
* R2: Number of bytes to read from VDP RAM
*
* Modifies R0-R2
*
vmbr:
       swpb r0
       movb r0,@vdpwa                  ; Send low byte of VDP RAM write address
       swpb r0
       movb r0,@vdpwa                  ; Send high byte of VDP RAM write address
vmbr0:
       li   r0,vdprd
vmbr1:
       movb *r0,*r1+                   ; Read byte from VDP RAM
       dec  r2                         ; Byte counter
       jne  vmbr1                      ; Check if finished
       b    *r11
*// vmbr

*********************************************************************
*
* Fast CPU to VDP copy, replaces VMBW
*
* R0: Destination address
* R1: Source address
* R2: Number of bytes to copy
*
* Modifies r0-r3
*
vdpcp:
       swpb r0
       movb r0,@vdpwa                  ; Send low byte of VDP RAM write address
       swpb r0
       ori  r0,>4000                   ; Set the two MSbits to 01 for write
       movb r0,@vdpwa                  ; Send high byte of VDP RAM write address
       li   r0,vdpwd
vdpcp0:
       mov  r2,r3
       srl  r3,3                       ; Number of groups of 8
       jeq  vdpcp2
vdpcp1:
       movb *r1+,*r0
       movb *r1+,*r0
       movb *r1+,*r0
       movb *r1+,*r0
       movb *r1+,*r0
       movb *r1+,*r0
       movb *r1+,*r0
       movb *r1+,*r0
       dec  r3
       jne  vdpcp1
       andi r2,>0007                   ; Isolate number of remaining bytes
       jeq  vdpcp3
vdpcp2:
       movb *r1+,*r0
       dec  r2
       jne  vdpcp2
vdpcp3:
       rt
*// vdpcp

*********************************************************************
*
* Fast CPU to VDP write, replaces VSMW
*
* R0: Destination address
* R1: Byte to write in MSB
* R2: Number of bytes to copy
*
* Modifies r0-r3
*
vdpwr:
       swpb r0
       movb r0,@vdpwa                  ; Send low byte of VDP RAM write address
       swpb r0
       ori  r0,>4000                   ; Set the two MSbits to 01 for write
       movb r0,@vdpwa                  ; Send high byte of VDP RAM write address
       li   r0,vdpwd
       mov  r2,r3
       srl  r3,3                       ; Number of groups of 8
       jeq  vdpwr2
vdpwr1:
       movb r1,*r0
       movb r1,*r0
       movb r1,*r0
       movb r1,*r0
       movb r1,*r0
       movb r1,*r0
       movb r1,*r0
       movb r1,*r0
       dec  r3
       jne  vdpwr1
       andi r2,>0007                   ; Isolate number of remaining bytes
       jeq  vdpwr3
vdpwr2:
       movb r1, *r0
       dec  r2
       jne  vdpwr2
vdpwr3:
       rt
*// vdpwr

*********************************************************************
*
* Data
*
byte_ff:
       byte >ff
byte_fe:
       byte >fe
byte_fc:
       byte >fc
byte_fb:
       byte >fb
byte_f5:
       byte >f5
byte_f4:
       byte >f4
byte_f3:
       byte >f3
byte_de:
       byte >de
byte_01:
       byte >01
       even

       copy "bmp-milk.a99"
       copy "bmp-objects.a99"
       copy "bmp-tiles.a99"
       copy "bmp-wally.a99"
       copy "furniture.a99"
       copy "rooms.a99"
       copy "room-object-slots.a99"

       end
