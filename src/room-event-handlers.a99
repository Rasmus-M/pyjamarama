room_update_vectors:
       equ  $
LE62B  data update_room_00  
LE62D  data update_room_01  
LE62F  data update_room_02  
LE631  data update_room_03  
LE633  data update_room_04  
LE635  data update_room_05  
LE637  data update_room_06  
LE639  data update_room_07  
LE63B  data update_room_08  
LE63D  data update_room_09  
LE63F  data update_room_0A  
LE641  data update_room_0B  
LE643  data update_room_0C  
LE645  data update_room_0D  
LE647  data update_room_0E  
LE649  data update_room_0F  
LE64B  data update_room_10  
LE64D  data update_room_11  
LE64F  data update_room_12  
LE651  data update_room_13  
LE653  data update_room_14  
LE655  data update_room_15  
LE657  data update_room_16  
LE659  data update_room_17  
LE65B  data update_room_18  
LE65D  data update_room_19  
LE65F  data update_room_1a  
LE661  data update_room_1b  
LE663  data update_room_1c  
LE665  data update_room_1d  
LE667  data update_room_1e  
LE669  data update_room_1e  
LE66B  data update_room_1e  
LE66D  data update_room_1e  
LE66F  data update_room_1e  
LE671  data update_room_1e  
LE673  data update_room_1e  
LE675  data update_room_1e

update_room_00:
       .proc
LE677  bl @Update_RollRock  
LE67A  .endproc  

update_room_01:
       .proc
LE67B  bl @update_roll_ball
LE67E  .endproc  

update_room_02:
       .proc
LE67F  bl @handler_angels
LE682  bl @handler_food
LE685  bl @handler_spooky_hand
LE688  .endproc  

update_room_03:
       .proc
LE689  bl @handler_chickens
LE68C  .endproc  

update_room_04:
       .proc
LE68D  bl @Handler_Darts
LE690  .endproc  

update_room_05:
       .proc
LE691  bl @Handler_BouncingAxe
LE694  .endproc  

update_room_06:
       .proc
LE695  bl @Handler_SavagePlant
LE698  .endproc  

update_room_07:
       .proc
LE699  bl @update_roll_ball
LE69C  .endproc  

update_room_08:
       .proc
LE69D  bl @Handler_Darts
LE6A0  .endproc  

update_room_09:
       .proc
LE6A1  bl @handler_food
LE6A4  bl @Handler_BalloonHelp  
LE6A7  bl @handler_spooky_hand
LE6AA  .endproc  

update_room_0A:
       .proc
LE6AB  bl @Handler_BouncingAxe
LE6AE  .endproc  

update_room_0B:
       .proc
LE6AF  bl @handler_angels
LE6B2  .endproc  

update_room_0C:
       .proc
LE6B3  bl @handler_angels
LE6B6  bl @handler_spooky_hand
LE6B9  .endproc  

update_room_0D:
       .proc
LE6BA  bl @handler_spooky_hand
LE6BD  .endproc  

update_room_0E:
       .proc
LE6BE  bl @handler_angels
LE6C1  .endproc  

update_room_0F:
       .proc
LE6C2  bl @handler_food
LE6C5  bl @Handler_Books  
LE6C8  .endproc  

update_room_10:
       .proc
LE6C9  bl @handler_moving_floor
LE6CC  bl @animate_moving_floor
LE6CF  bl @handler_spooky_hand
LE6D2  .endproc  

update_room_11:
       .proc
LE6D3  bl @handler_food
LE6D6  bl @handler_angels
LE6D9  .endproc  

update_room_12:
       .proc
LE6DA  bl @Handler_BouncingAxe
LE6DD  .endproc  

update_room_13:
       .proc
LE6DE  bl @Handler_Darts
LE6E1  .endproc  

update_room_14:
       .proc
LE6E2  bl @handler_spooky_hand
LE6E5  .endproc  

update_room_15:
       .proc
LE6E6  bl @handler_food
LE6E9  bl @Handler_BouncingAxe  
LE6EC  .endproc  

update_room_16:
       .proc
LE6ED  bl @Handler_Ghosts
LE6F0  .endproc  

update_room_17:
       .proc
LE6F1  bl @Handler_Ghosts
LE6F4  bl @handler_food
LE6F7  .endproc  

update_room_18:
       .proc
LE6F8  bl @handler_spooky_hand
LE6FB  .endproc  

update_room_19:
       .proc
LE6FC  bl @Handler_Invaders
LE6FF  bl @Pause_Short  
LE702  bl @Pause_Short  
LE705  .endproc  

update_room_1a:
       .proc
LE706  bl @handler_food
LE709  bl @Handler_ThreeTon  
LE70C  .endproc  

update_room_1b:
       .proc
LE70D  bl @Handler_ThreeTon
LE710  bl @handler_spooky_hand
LE713  .endproc  

update_room_1c:
       .proc
LE714  bl @Handler_FallingBlocks
LE717  bl @Handler_Fire  
LE71A  .endproc  

update_room_1d:
       .proc
LE71B  bl @Handler_BouncingAxe
LE71E  bl @Handler_MagLock  
LE721  bl @Handler_MagLock  
LE724  bl @Handler_MagLock  
LE727  bl @Handler_MagLock  
LE72A  bl @Handler_MagLock  
LE72D  .endproc  

update_room_1e:
       .proc
LE72E  bl @Inv_Update
LE731  bl @Inv_Update  
LE734  bl @Inv_Update  
LE737  bl @Inv_Update  
LE73A  bl @Inv_Update  
LE73D  bl @Inv_Update  
LE740  bl @Arcade_UpdateExplosions  
LE743  bl @Inv_BulletUpdate  
LE746  bl @Arcade_UpdateBombs  
LE749  .endproc  

*********************************************************************
*
Update_RollRock:
       .proc
       .endproc

*********************************************************************
*
update_roll_ball:
       .proc
       movb @flag_baddy_init,r0
       jne  update_roll_ball_0
       movb @byte_01,@flag_baddy_init
       bl   @allocate_sprite
       mov  r0,@roll_ball_sprite
       mov  r0,r4
       li   r1,>3008
       mov  r1,*r4+                    ; Set position
       li   r0,>008d                   ; Pattern
       mov  r0,@roll_ball_bmp
       bl   @get_sprite_pattern
       movb r1,*r4+
       movb @byte_0b,*r4               ; Color
       jmp  update_roll_ball_4
update_roll_ball_0:
       mov  @roll_ball_sprite,r4
       mov  *r4,r0                     ; Get position
       mov  @roll_ball_bmp,r1
       cb   @r0lb,@byte_b0             ; At end of railing?
       jne  update_roll_ball_3         ; Jump if not
       ab   @byte_02,r0                ; Move down
       cb   r0,@byte_aa
       jl   update_roll_ball_1
       li   r0,>3008
update_roll_ball_1:
       mov  r0,*r4                     ; Store position
       andi r0,>0003                   ; Animate
       jne  update_roll_ball_2
       inc  r1
       ci   r1,>0090
       jne  update_roll_ball_2
       li   r1,>008d
update_roll_ball_2:
       mov  r1,@roll_ball_bmp
       mov  r1,r0
       bl   @get_sprite_pattern
       movb r1,@sprite_pattern(r4)     ; Store pattern
       li   r0,10
       mov  *r4,r1
       bl   @wally_hit_test
       jmp  update_roll_ball_4
update_roll_ball_3:
       mov  r0,r2
       ab   @byte_02,@r0lb             ; Move right
       cb   @r2lb,@byte_1a
       jl   update_roll_ball_1
       ab   @byte_01,r0                ; Move slanted
       jmp  update_roll_ball_1
update_roll_ball_4:
       .endproc
roll_ball_sprite
       data 0
roll_ball_bmp:
       data 0
*// update_roll_ball

*********************************************************************
*
handler_angels:
       .proc
       movb @flag_baddy_init,r0        ; See if angels have been intialised.
       jne  handler_angels_0
*      Initialize
       movb @byte_01,@flag_baddy_init  ; Set as initialised.
       li   r0,>0002
       mov  r0,@angel1_direction       ; Set directions all the same.
       mov  r0,@angel2_direction
       mov  r0,@angel3_direction
       li   r0,>0093
       mov  r0,@angel_frame
       bl   @get_sprite_pattern
       li   r3,>0004                   ; Color
       movb r1,r3                      ; Pattern
       bl   @allocate_sprite           ; Set positions and draw each angel.
       mov  r0,@angel1_sprite
       li   r1,>3278
       mov  r1,*r0+
       mov  r3,*r0
       bl   @allocate_sprite
       mov  r0,@angel2_sprite
       li   r1,>6438
       mov  r1,*r0+
       mov  r3,*r0
       bl   @allocate_sprite
       mov  r0,@angel3_sprite
       li   r1,>50b8
       mov  r1,*r0+
       mov  r3,*r0
       jmp  handler_angels_end
* Update
handler_angels_0:
       mov  @angel_frame,r0            ; Get bitmap frame for all angels.
       inc  r0                         ; Update to next frame.
       ci   r0,>0099                   ; Check to see if frame needs to loop around.
       jne  handler_angels_1
       li   r0,>0093
handler_angels_1:
       mov  r0,@angel_frame
       bl   @get_sprite_pattern
       mov  r1,r6
       li   r7,angel1_sprite           ; Point index to first angel.
       li   r8,3                       ; Number of angels to update.
handler_angels_2:
       mov  *r7+,r4                    ; Get sprite
       movb r6,@sprite_pattern(r4)
       ab   @1(r7),*r4                 ; Add velocity to y position
       cb   *r4,@byte_aa               ; See if at bottom of screen.
       jhe  handler_angels_3
       cb   *r4,@byte_30               ; See if at top of screen.
       jh   handler_angels_4
handler_angels_3:
       neg  *r7
handler_angels_4:
       li   r0,4                       ; Amount of energy loss if angel hits wally.
       mov  *r4,r1
       bl   @wally_hit_test
       inct r7
       dec  r8
       jne  handler_angels_2
handler_angels_end:
       .endproc

angel1_sprite:                         ; Sprite pointer
       data >0000
angel1_direction:                      ; Direction / Velocity of sprite.
       data >0002
angel2_sprite:
       data >0000
angel2_direction:
       data >0002
angel3_sprite:
       data >0000
angel3_direction:
       data >0002
angel_frame:                           ; Bitmap index. (93 ~ 98)
       data >0093

*********************************************************************
*
handler_food:
       .proc
       movb @flag_food_drawn,r0
       jne  handler_food_1
       movb @byte_01,@flag_food_drawn
       mov  @food_active_ptr,r1        ; Get info of currently active food.
       movb @wally_room_no+1,r0
       cb   r0,*r1                     ; See if is same room as Wally, returning if not.
       jeq  handler_food_0
       ai   r1,>0016
       cb   r0,*r1
       jne  handler_food_1
handler_food_0:
       inc  r1                         ; Get X position of food.
       movb *r1+,@bitmap_x+1
       li   r0,>00a8
       mov r0,@bitmap_y
       clr  r0
       movb *r1,@r0lb                  ; Get bitmap to display.
       bl   @bitmap_16_draw
handler_food_1:
       .endproc

*********************************************************************
*
handler_spooky_hand:
       .proc
       mov  @spooky_hand_countdown,r0  ; Check count down, animating hand if already zero.
       jeq  handler_spooky_hand_update
       dec  @spooky_hand_countdown
       jne  handler_spooky_hand_end
       mov  @wally_room_no,r0          ; Get data for current room with a spooky hand. (Assumes this routine is only called by rooms that match.)
       swpb r0
       li   r3,spooky_hand_pos_table
handler_spooky_hand_0:
       cb   *r3+,r0
       jeq  handler_spooky_hand_1
       inct r3
       jmp  handler_spooky_hand_0
handler_spooky_hand_1:
       bl   @allocate_sprite           ; r0 contains address of sprite
       mov  r0,r4
       movb *r3+,@sprite_x(r4)         ; x
       movb *r3,*r4                    ; y
       li   r0,>00ad
       mov  r0,@spooky_hand_frame
       bl   @get_sprite_pattern
       movb r1,@sprite_pattern(r4)
       movb @byte_09,@sprite_color(r4)
       mov  r4,@spooky_hand_sprite
       jmp  handler_spooky_hand_end
* Update spooky hand for animation.
handler_spooky_hand_update:
* Check delay for a frame, exit if not ready to update.
       dec  @spooky_hand_frame_delay
       jne  handler_spooky_hand_end
       li   r0,>0004                   ; Set frame delay.
       mov  r0,@spooky_hand_frame_delay
       mov  @spooky_hand_sprite,r4
       mov  @spooky_hand_frame,r0
       inc  r0                         ; Next frame
       ci   r0,>00b3                   ; Check for end of animation, restarting countdown if end reached.
       jeq  handler_spooky_hand_2
       mov  r0,@spooky_hand_frame
       bl   @get_sprite_pattern
       movb r1,@sprite_pattern(r4)
       li   r0,2
       mov  *r4,r1
       bl   @wally_hit_test
       jmp  handler_spooky_hand_end
handler_spooky_hand_2:
       li   r0,>32
       mov  r0,@spooky_hand_countdown
       mov  r4,r0
       bl   @deallocate_sprite
handler_spooky_hand_end:
       .endproc

spooky_hand_countdown:
       data >0030                      ; Spooky Hand countdown. When zero reached hand appears out of ground.
spooky_hand_pos_table:
       byte >02,>68,>A8                ; Room and position of each spooky hand.
       byte >09,>40,>A8
       byte >0D,>60,>A8
       byte >10,>A0,>A8
       byte >14,>A8,>A8
       byte >18,>88,>78
       byte >1B,>20,>90
       byte >0C,>D8,>88
spooky_hand_frame:
       data >0000                      ; Index of current spooky hand bitmap.
spooky_hand_frame_delay:
       data >0004
spooky_hand_sprite:
       data >0000

*********************************************************************
*
* Room Event : Cooked Chickens
*
handler_chickens:
       .proc
       movb @flag_baddy_init,r0
       jne  handler_chickens_1
       movb @byte_01,@flag_baddy_init
       li   r0,>007b
       mov  r0,@chicken_frame
       bl   @get_sprite_pattern
       mov  r1,r3
       movb @byte_06,@r3lb
       bl   @allocate_sprite
       mov  r0,@chicken1_sprite
       li   r1,>8088
       mov  r1,*r0+
       mov  r3,*r0
       bl   @allocate_sprite
       mov  r0,@chicken2_sprite
       li   r1,>a8a8
       mov  r1,*r0+
       mov  r3,*r0
       jmp handler_chickens_9
handler_chickens_1:
       mov  @frame,r0
       andi r0,3
       jne  handler_chickens_3
       mov  @chicken_frame,r0
       inc  r0
       ci   r0,>007f
       jne  handler_chickens_2
       li   r0,>007b
handler_chickens_2:
       mov  r0,@chicken_frame
       bl   @get_sprite_pattern
       movb r1,r9
handler_chickens_3:
       li   r6,2
       li   r7,chicken1_sprite
handler_chickens_4:
       mov  *r7+,r8
       movb r9,@sprite_pattern(r8)
       li   r0,1
       mov  *r8,r1
       bl   @wally_hit_test
       mov  *r8,r1                     ; Get y and x
       cb   r1,@byte_80                ; Is chicken on table?
       jne  handler_chickens_5         ; Jump if not
       sb   @byte_02,@r1lb             ; Move left
       cb   @r1lb,@byte_78             ; Reached edge of table?
       jne  handler_chickens_8         ; Jump if not
       movb @byte_82,r1                ; Start the drop
       jmp  handler_chickens_8         ; Next chicken
*      Not on table
handler_chickens_5:
       cb   r1,@byte_a8                ; On the floor?
       jeq  handler_chickens_6
*      Dropping to the floor
       ab   @byte_02,r1                ; Move down
       jmp  handler_chickens_8         ; Next chicken
*      On floor
handler_chickens_6:
       ci   r6,1
       jeq  handler_chickens_7
*      Move left
       sb   @byte_02,@r1lb             ; Move left
       cb   @r1lb,@byte_08
       jne  handler_chickens_8
       li   r1,>80b4
       jmp  handler_chickens_8
*      Move right
handler_chickens_7:
       ab   @byte_02,@r1lb             ; Move right
       cb   @r1lb,@byte_e8
       jne  handler_chickens_8
       li   r1,>80b4
handler_chickens_8:
       mov  r1,*r8                     ; Write y and x
       dec  r6
       jne  handler_chickens_4

handler_chickens_9:
       .endproc

chicken_frame:
       data >007b                       Index of chicken bitmap
chicken1_sprite:
       data >0000
chicken2_sprite:
       data >0000

*********************************************************************
*
Handler_Darts:
       .proc
       .endproc

*********************************************************************
*
Handler_BouncingAxe:
       .proc
       .endproc

*********************************************************************
*
Handler_SavagePlant:
       .proc
       .endproc

*********************************************************************
*
Handler_BalloonHelp:
       .proc
       .endproc

*********************************************************************
*
Handler_Books:
       .proc
       .endproc

*********************************************************************
*
handler_moving_floor:
       .proc
       movb @death_flag,r0             ; Ignore if dead.
       jne  handler_moving_floor_2
       cb   @pocket_1+1,@byte_12       ; See if Wally is carrying the remote control. If he is don't update making it look like the floor has been stopped.
       jeq  handler_moving_floor_2
       cb   @pocket_2+1,@byte_12
       jeq  handler_moving_floor_2
       cb   @wally_y,@byte_91          ; If Wally is above the floor then don't update.
       jl   handler_moving_floor_2
       movb @wally_x,r0
       ab   @byte_02,r0
       cb   r0,@byte_e8
       jle  handler_moving_floor_1
       movb @byte_e8,r0
handler_moving_floor_1:
       movb r0,@wally_x
handler_moving_floor_2:
       .endproc

*********************************************************************
*
* Scrolls the top two layers of the floor, animating it like a travelator.
*
animate_moving_floor:
       .proc
       cb   @pocket_1+1,@byte_12
       jeq  animate_moving_floor_2
       cb   @pocket_2+1,@byte_12
       jeq  animate_moving_floor_2
       cb   @death_flag,@byte_01
       jeq  animate_moving_floor_2
       li   r0,>1700
       bl   @vsbr
       clr  r3
       movb r1,r3
       srl  r3,2
       socb @r3lb,r3
       clr  r4
       movb @vdprd,r4
       srl  r4,2
       socb @r4lb,r4
       li   r0,>1700+>4000
       li   r2,32
animate_moving_floor_1:
       movb @r0lb,@vdpwa
       movb r0,@vdpwa
       bl   @vwad
       movb r3,*r15
       movb r4,*r15
       ai   r0,8
       dec  r2
       jne  animate_moving_floor_1
animate_moving_floor_2:
       .endproc

*********************************************************************
*
Handler_Ghosts:
       .proc
       .endproc

*********************************************************************
*
Handler_Invaders:
       .proc
       .endproc

*********************************************************************
*
Pause_Short:
       .proc
       .endproc

*********************************************************************
*
Handler_ThreeTon:
       .proc
       .endproc

*********************************************************************
*
Handler_FallingBlocks:
       .proc
       .endproc

*********************************************************************
*
Handler_Fire:
       .proc
       .endproc

*********************************************************************
*
Handler_MagLock:
       .proc
       .endproc

*********************************************************************
*
Inv_Update:
       .proc
       .endproc

*********************************************************************
*
Arcade_UpdateExplosions:
       .proc
       .endproc

*********************************************************************
*
Inv_BulletUpdate:
       .proc
       .endproc

*********************************************************************
*
Arcade_UpdateBombs:
       .proc
       .endproc
