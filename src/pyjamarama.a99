*********************************************************************
*
* Pyjamarama
* For the TI-99/4A home computer
*
* November 2018
* Rasmus Moustgaard <rasmus.moustgaard@gmail.com>
*
*********************************************************************

       def  main

**
* Assembly options
*
immunity:
       equ  0

**
* Constants
*

**
* Memory mapped addresses
*
vdpwd  equ  >8c00                      ; VDP write data
vdpwa  equ  >8c02                      ; VDP set read/write address
vdprd  equ  >8800                      ; VDP read data
vdpsta equ  >8802                      ; VDP status
sound  equ  >8400

**
* VDP memory map
*
ptrntb equ  >0000                      ; Pattern table base
sprptb equ  >1800                      ; Sprite pattern table base
colrtb equ  >2000                      ; Color table base
nametb equ  >3800                      ; Name table base
spratb equ  >3C00                      ; Sprite attribute table base 1

**
* Structures
*

**
* Scratch pad
*
pad    equ  >8300
wrksp  equ  pad                        ; Workspace
r0lb   equ  wrksp+1                    ; r0 low byte required for VDP routines
r1lb   equ  wrksp+3
r2lb   equ  wrksp+5
r3lb   equ  wrksp+7
r4lb   equ  wrksp+9
r5lb   equ  wrksp+11
r6lb   equ  wrksp+13
r7lb   equ  wrksp+15
r8lb   equ  wrksp+17
r9lb   equ  wrksp+19
stack  equ  pad+>20                    ; Stack (grows up)
padvar equ  stack+>10                  ; Start of pad variables
*
* PAD variables
*
wally_room_no:
       equ  padvar
wally_lives:
       equ  wally_room_no+2
wally_x:
       equ  wally_lives+2
wally_y:
       equ  wally_x+2
pocket_1:
       equ  wally_y+2
pocket_2:
       equ  pocket_1+2
tile_flip_vertical:
       equ  pocket_2+2
tile_start_ptr:
       equ  tile_flip_vertical+2
bitmap_x:
       equ  tile_start_ptr+2
bitmap_y:
       equ  bitmap_x+2
food_active_ptr:
       equ  bitmap_y+2
pad_max:
       equ  food_active_ptr+2
**
* Macros
*
       .defm proc
       mov  r11,*r10+
       .endm

       .defm endproc
       dect r10
       mov  *r10,r11
       b    *r11
       .endm

********************************************************************************
*
* Main program
*
       aorg >a000
main:
       limi 0                          ; Interrupts off
       lwpi wrksp                      ; Setup workspace
       li   r10,stack                  ; Setup stack pointer
       li   r15,vdpwd                  ; Do not change
       li   r0,padvar
       li   r2,pad_max-padvar
init_pad:
       clr  *r0+
       dect r2
       jne  init_pad
       bl   @bitmap_mode
       li   r0,1
       mov  r0,@wally_room_no
loop:  bl   @game_start
       bl   @wait_key
       mov  @wally_room_no,r0
       inc  r0
       ci   r0,30
       jlt  !
       clr  r0
!      mov  r0,@wally_room_no
       jmp  loop

********************************************************************************
*
* Start a new game
*
game_start:
       .proc
       bl   @screen_clear_simple
       bl   @game_init_stats
       bl   @room_draw
       li   r0,>0001
       li   r1,scoreboard_item
       bl   @furniture_draw
       bl   @inv_redraw
       bl   @lives_reset
       bl   @milk_draw_full
       .endproc
*// game_start

********************************************************************************
*
* Start a new game
*
game_init_stats:
       .proc
       li   r0,>0000                   ; The Round Key
       mov  r0,@pocket_1
       li   r0,>0001                   ; The Radio
       mov  r0,@pocket_2
       li   r0,food_table              ; Reset active food
       mov  r0,@food_active_ptr
*      Clear all the object flags
       li   r2,>16                      .
       li   r0,lift_count
game_init_stats_0:
       clr  *r0+
       dect r2
       jne  game_init_stats_0
*      Reset object positions by filling in the object slots, for each room, with and object index in incremental steps
       li   r0,room_obj_slot_Obj
       li   r2,>1e
       li   r1,>0200
game_init_stats_1:
       movb r1,*r0+
       inct r0
       ai   r1,>0100
       dec  r2
       jne  game_init_stats_1
*      Clear all object found markers
       li   r0,object_found_table      ;
       li   r2,>20
       clr  r1
game_init_stats_2:
       movb r1,*r0
       inct r0
       dec  r2
       jne  game_init_stats_2
*      Clear all rooms visited
       li   r2,>23
game_init_stats_3:
       movb r1,*r0+
       dec  r2
       jne  game_init_stats_3
       .endproc
*// game_init_stats

********************************************************************************
*
* Reset lives
*
lives_reset:
       .proc
       li   r0,3
       mov  r0,@wally_lives
       li   r0,3
lives_reset_1:
       mov  r0,*r10+                   ; Push r0
       bl   @life_draw_blit
       dect r10                        , Pop r0
       mov  *r10,r0
       dec  r0
       jne  lives_reset_1
       .endproc
*// lives_reset

********************************************************************************
*
* Redraw inventory area
*
inv_redraw:
       .proc
       bl   @screen_clear
       mov  @pocket_1,r1
       sla  r1,1
       mov  @object_text_ptr_table(r1),r4
       mov  @pocket_2,r1
       sla  r1,1
       mov  @object_text_ptr_table(r1),r5
       li   r0,bmp_tiles               ; Reset the start address of the tiles back to tile zero for true ZX ASCII letters within tiles.
       mov  r0,@tile_start_ptr
;E51D	LD E,$14
;E51F	LD D,$00
;E521	LD C,$44
;E523	CALL InventoryDrawText
;E526	POP HL
;E527	LD E,$14
;E529	LD D,$02
;E52B	LD C,$45
;E52D	CALL InventoryDrawText
       mov  @pocket_1,r0
       ai   r0,>50
       li   r1,>0088
       mov  r1,@bitmap_x
       clr  @bitmap_y
       bl   @bitmap_16_draw
       mov  @pocket_2,r0
       ai   r0,>50
       li   r1,>0010
       mov  r1,@bitmap_y
       bl   @bitmap_16_draw
       .endproc
*// inv_redraw

********************************************************************************
*
* Room draw
*
room_draw:
       .proc
       mov  @wally_room_no,r4          ; Get room number.
       sla  r4,1                       ; Work out address of room pointer.
       mov  @room_data(r4),r4          ; Get address to room description data.
       movb *r4,r0
       cb   r0,@byte_f5                ; Get first byte and test for drawing of walls etc.
       jne  room_draw_1
       bl   @draw_ceiling_wall_floor
       inc  r4
*      Draw furniture
room_draw_1:
       movb *r4+,r0
       cb   r0,@byte_ff
       jeq  room_draw_5                ; End marker
       cb   r0,@byte_f4
       jne  room_draw_2
       seto @tile_flip_vertical             ; Draw upside down
       jmp  room_draw_1
room_draw_2:
       cb   r0,@byte_f3
       jne  room_draw_3
       clr  @tile_flip_vertical             ; Draw normal
       jmp  room_draw_1
room_draw_3:
       cb   r0,@byte_de
       jne  room_draw_4
       movb *r4+,r1                    ; Get address of action flag.
       movb *r4+,@r1lb
       movb *r1,r0                     ; Get action flag
       jeq  room_draw_5                ; If not set then handle action,
       jmp  room_draw_1                ; else continue onto next byte.
room_draw_4:
       swpb r0
       movb *r4+,r0                    ; y position (x in MSB)
       clr  r1
       movb *r4+,@r1lb                 ; Get index of furniture item.
       sla  r1,1
       mov  @furniture_table(r1),r1    ; Workout address of item string.
       bl   @furniture_draw
       jmp  room_draw_1
*      Draw object
room_draw_5:
       mov  @wally_room_no,r3
       sla  r3,1                       ; x2
       a    @wally_room_no,r3          ; x3
       ai   r3,room_obj_slots
       clr  r0
       movb *r3+,@r0lb
       mov  r0,@bitmap_x
       movb *r3+,@r0lb
       ai   r0,>10
       mov  r0,@bitmap_y
       movb *r3,@r0lb
       ai   r0,>50
       bl   @bitmap_16_draw
       .endproc
*// room_draw

*********************************************************************************
*
* Draw furniture
*
* Input:
* r0 MSB: y position
* r0 LSB: x position
* r1: Address of furniture item string
*
furniture_draw:
       .proc
       mov  r1,r5                      ; Save address
       mov  r0,r6                      ; Save position
furniture_draw_6:
       movb *r5+,r0                    ; Get next byte in string.
       jgt  furniture_draw_4           ; Test for normal tile.
       jeq  furniture_draw_4
       cb   r0,@byte_ff                ; Test for END OF STRING value.
       jeq  furniture_draw_5
       cb   r0,@byte_fe                ; Test for code.
       jne  furniture_draw_0
       movb *r5+,r0                    ; Get colour.
       bl   @ti_color                  ; Convert to TI color
       mov  r1,r7                      ; Save color
       jmp  furniture_draw_6
furniture_draw_0:
       cb   r0,@byte_fc                ; Test for code.
       jne  furniture_draw_1
       ab   *r5+,@r6lb                 ; Px += Sx
       ab   *r5+,r6                    ; Py += Sy
       jmp  furniture_draw_6
furniture_draw_1:
       cb   r0,@byte_fb                ; Test for code.
       jne  furniture_draw_2
       movb *r5+,@r0lb                 ; Get next two bytes holding new tile start address.
       movb *r5+,r0
       ci   r0,>c1a0
       jl  !
       ai   r0,bmp_tiles->c1a0         ; Adjust address
       jmp  !!
!      ai   r0,tile_ceiling->8c4d      ; Adjust address for ceiling/roof/floor tiles
!      mov  r0,@tile_start_ptr         ; Store for tile_draw to use
       jmp  furniture_draw_6
furniture_draw_2:
       clr  r8
       movb *r5+,@r8lb                 ; Get number of times to draw.
       movb *r5+,r9                    ; Get tile(n) to draw.
furniture_draw_3:
       mov  r9,r0                      ; Tile number
       mov  r6,r1                      ; Position
       mov  r7,r2                      ; Color
       bl   @tile_draw                 ; Draw tile.
       inc  r6                         ; Px++
       dec  r8
       jne  furniture_draw_3
       jmp  furniture_draw_6
furniture_draw_4:
       mov  r6,r1                      ; Position
       mov  r7,r2                      ; Color
       bl   @tile_draw
       inc  r6                         ; Px++
       jmp  furniture_draw_6
furniture_draw_5:
       .endproc
*// furniture_draw

*********************************************************************************
*
* Draw ceiling, wall and floor
*
draw_ceiling_wall_floor:
       .proc
       li   r0,tile_ceiling
       mov  r0,@tile_start_ptr
*      Ceiling
       li   r6,>0500
       li   r8,>20
draw_ceiling_wall_floor_1:
       clr  r0
       mov  r6,r1
       li   r2,>d100
       bl   @tile_draw
       inc  r6
       dec  r8
       jne  draw_ceiling_wall_floor_1
*      Floor
       li   r6,>1700
       li   r8,>20
draw_ceiling_wall_floor_2:
       li   r0,>0100
       mov  r6,r1
       li   r2,>7100
       bl   @tile_draw
       inc  r6
       dec  r8
       jne  draw_ceiling_wall_floor_2
*      Left wall
       li   r6,>0600
       li   r8,>11
draw_ceiling_wall_floor_3:
       li   r0,>0200
       mov  r6,r1
       li   r2,>8100
       bl   @tile_draw
       ab   @byte_01,r6
       dec  r8
       jne  draw_ceiling_wall_floor_3
*      Right wall
       li   r6,>061f
       li   r8,>11
draw_ceiling_wall_floor_4:
       li   r0,>0200
       mov  r6,r1
       li   r2,>8100
       bl   @tile_draw
       ab   @byte_01,r6
       dec  r8
       jne  draw_ceiling_wall_floor_4
       .endproc
*// draw_ceiling_wall_floor

*********************************************************************************
*
* Draw tile
*
* Input:
* r0 MSB: Tile number
* r1 MSB: y position
* r1 LSB: x position
* r2 MSB: color
* Modifies r3
*
tile_draw:
       .proc
       mov  r1,r3                      ; x and y positions
       andi r3,>001f                   ; x position
       sla  r3,3                       ; x8
       andi r1,>1f00                   ; y position
       abs  @tile_flip_vertical
       jeq  !
       neg  r1                         ; Invert y
       ai   r1,>1C00
!      movb r1,r3
       clr  r1
       movb r0,@r1lb                   ; Tile number
       sla  r1,3                       ; x8
       a    @tile_start_ptr,r1         ; Add base address
*      Draw color
       mov  r3,r0
       ai   r0,colrtb
       bl   @vwad
       movb r2,*r15
       movb r2,*r15
       movb r2,*r15
       movb r2,*r15
       movb r2,*r15
       movb r2,*r15
       movb r2,*r15
       movb r2,*r15
*      Draw tile
       abs  @tile_flip_vertical
       jne  tile_draw_1
*      Draw normal tile
       mov  r3,r0
       bl   @vwad
       movb *r1+,*r15
       movb *r1+,*r15
       movb *r1+,*r15
       movb *r1+,*r15
       movb *r1+,*r15
       movb *r1+,*r15
       movb *r1+,*r15
       movb *r1+,*r15
       jmp  tile_draw_2
tile_draw_1:
*      Draw upside down tile
       mov  r3,r0
       bl   @vwad
       ai   r1,7
       movb *r1,*r15
       dec  r1
       movb *r1,*r15
       dec  r1
       movb *r1,*r15
       dec  r1
       movb *r1,*r15
       dec  r1
       movb *r1,*r15
       dec  r1
       movb *r1,*r15
       dec  r1
       movb *r1,*r15
       dec  r1
       movb *r1,*r15
       dec  r1
tile_draw_2:
       .endproc
*// tile_draw

*********************************************************************************
*
* Draw full milk glass
*
milk_draw_full:
       .proc
       li   r0,13*8                    ; Destination
       li   r1,bmp_milk_full
       li   r2,4                       ; 4 rows
milk_draw_full_1:
       bl   @vwad
       li   r3,3                       ; 3 columns
milk_draw_full_2:
       li   r4,8                       ; 8 lines
milk_draw_full_3:
       movb *r1+,*r15
       inct r1
       dec  r4
       jne  milk_draw_full_3
       ai   r1,-23
       dec  r3
       jne  milk_draw_full_2
       ai   r0,256
       ai   r1,21
       dec  r2
       jne  milk_draw_full_1
       .endproc
*// milk_draw_full

*********************************************************************************
*
* Draw 16x16 bitmap
*
* Input:
* r0: Index of bitmap to draw
* @bitmap_x: x coordinate
* @bitmap_y: y coordinate
*
bitmap_16_draw:
       .proc
       li   r4,bmp_wally
       sla  r0,5
       a    r0,r4                      ; Source address
       mov  @bitmap_x,r0
       mov  @bitmap_y,r1
       bl   @screen_address            ; Result in r6,r7
       ori  r6,>4000                   ; Setup as write address
*      Setup shifts
       mov  r7,r0                      ; Bit offset
       jeq  bitmap_16_draw_1
       mov  @opcode_srl,r8             ; Right shift by offset
       sla  r0,4
       soc  r0,r8
       mov  @opcode_sla,r9             ; Left shift by (8-offset)
       li   r0,8
       s    r7,r0
       sla  r0,4
       soc  r0,r9
       jmp  bitmap_16_draw_2
bitmap_16_draw_1:
       mov  @opcode_nop,r8             ; No shift
       mov  r8,r9
*      1-8 lines of first character row
bitmap_16_draw_2:
       mov  r6,r0
       andi r0,7
       li   r3,8                       ; Line counter
       s    r0,r3
       bl   @bitmap_16_draw_section
*      Full character row
       ai   r6,>0100                   ; Next character row
       andi r6,>fff8                   ; Align to beginning of row
       li   r3,8
       bl   @bitmap_16_draw_section
*      0-7 lines of last character row
       mov  @bitmap_y,r3
       andi r3,7
       jeq  bitmap_16_draw_3
       ai   r6,>0100                   ; Next character row
       andi r6,>fff8                   ; Align to beginning of row
       bl   @bitmap_16_draw_section
bitmap_16_draw_3:
       .endproc
bitmap_16_draw_section:
       mov  r6,r5
*      First byte
       movb @r5lb,@vdpwa               ; Setup VDP write address
       movb r5,@vdpwa
       mov  r4,r0                      ; Source address
       mov  r3,r2
bitmap_16_draw_section_1:
       mov  *r0+,r1                    ; Get source word
       x    r8                         ; Shift right
       movb r1,*r15                    ; Send MSB to VDP
       dec  r2
       jne  bitmap_16_draw_section_1
*      Second byte
       ai   r5,8
       movb @r5lb,@vdpwa               ; Setup VDP write address
       movb r5,@vdpwa
       mov  r4,r0                      ; Source address
       mov  r3,r2
bitmap_16_draw_section_2:
       mov  *r0+,r1                    ; Get source word
       x    r8                         ; Shift right
       movb @r1lb,*r15                 ; Send LSB to VDP
       dec  r2
       jne  bitmap_16_draw_section_2
*      Third byte
       abs  r7
       jeq  bitmap_16_draw_section_4
       ai   r5,8
       movb @r5lb,@vdpwa               ; Setup VDP write address
       movb r5,@vdpwa
       mov  r4,r0                      ; Source address
       mov  r3,r2
bitmap_16_draw_section_3:
       mov  *r0+,r1                    ; Get source word
       x    r9                         ; Shift left
       movb @r1lb,*r15                 ; Send LSB to VDP
       dec  r2
       jne  bitmap_16_draw_section_3
bitmap_16_draw_section_4:
       mov  r0,r4
       rt
opcode_srl:
       srl  r1,0
opcode_sla:
       sla  r1,0
opcode_nop:
       nop
*// bitmap_16_draw

********************************************************************************
*
* Draw life
*
* Input:
* r0: life number 0-
*
life_draw_blit:
       .proc
       dec  r0
       sla  r0,4                       ; x16
       mov  r0,@bitmap_x
       li   r0,16
       mov  r0,@bitmap_y
       li   r0,>4c                     ; Index for Life Bitmap
       bl   @bitmap_16_draw
       .endproc
*// life_draw_blit

*********************************************************************
*
* Calculate screen address and bit mask from coordinates
* Based on E/A manual page 336       
*
* Input:
* r0 x value
* r1 y value
*
* On return:
* r6  Set to byte offset
* r7  Set to bit offset
*
screen_address:
       mov  r1,r6                      ; 00000000yyyyyyyy
       sla  r6,5                       ; 000yyyyyyyy00000
       soc  r1,r6                      ; 000yyyyy???yyyyy
       andi r6,>ff07                   ; 000yyyyy00000yyy
       mov  r0,r7                      ; 00000000xxxxxxxx
       andi r7,7                       ; 0000000000000xxx
       a    r0,r6                      ; 000yyyyyxxxxx???
       s    r7,r6                      ; 000yyyyyxxxxxyyy
       rt
*// screen_address

*********************************************************************************
*
* Get TI-99 color from ZX Spectrum color
*
* r0 MSB: Colour-byte FBPPPIII
*  - I - Ink colour (0-7)
*  - P - Paper colour (0-7)
*  - B - Bright (0-No, 1-Yes)
*  - F - Flash  (0-No, 1-Yes)
*
* Modifies r2-r3
* On return r1 MSB contains the TI color FFFFBBBB.
*
ti_color:
       clr  r1
*      Foreground
       mov  r0,r2
       andi r2,>0700                   ; Foreground bits
       mov  r0,r3
       andi r3,>4000                   ; Bright bit
       srl  r3,3
       soc  r3,r2
       swpb r2
       movb @tipal(r2),r1
       sla  r1,4
*      Background
       mov  r0,r2
       andi r2,>3800                   ; Background bits
       srl  r2,3
       soc  r3,r2
       swpb r2
       movb @tipal(r2),r3
       socb r3,r1
*      Flash
       andi r0,>8000
       jeq  !
       srl  r1,4
       andi r1,>0ff0
       socb @r1lb,r1
!      rt

* Spectrum palette
* 0  Black,    1 D Blue,   2 D Red,     3 D Magenta
* 4  D Green,  5 D Cyan,   6 D Yellow,  7 Grey
* 8  Black,    9 Blue,    10 Red,      11 Magenta
* 12 Green,   13 Cyan,    14 Yellow,   15 White

* TI palette
* 0  Trans,    1 Black,    2 M Green,   3 L Green
* 4  D Blue,   5 L Blue,   6 D Red,     7 Cyan
* 8  M Red,    9 L Red,   10 D Yellow, 11 L Yellow
* 12 D Green, 13 Magenta, 14 Gray,     15 White

tipal  byte 1,4,6,13,12,7,10,14,1,5,8,13,2,7,11,15
* Not used: 3 L Green, 9 L Red
* Not available: D Cyan, D Magenta
*// ti_color

*********************************************************************************
*
* Clear inventory area
*
screen_clear:
       .proc
       li   r0,17*8
       li   r2,4
screen_clear_1:
       bl   @vwad
       li   r3,15*8
screen_clear_2:
       clr  *r15
       dec  r3
       jne  screen_clear_2
       ai   r0,256
       dec  r2
       jne  screen_clear_1
       .endproc
*// screen_clear

*********************************************************************************
*
* Clear whole screen
*
screen_clear_simple:
       .proc
*      Patterns
       li   r0,ptrntb
       li   r1,>0000
       li   r2,>1800
       bl   @vdpwr
*      Colors
       li   r0,colrtb
       li   r1,>a100
       li   r2,>1800
       bl   @vdpwr
       .endproc
*// screen_clear_simple

*********************************************************************************
*
* Set full bitmap mode
*
bitmap_mode:
       .proc
       clr  r0
       li   r1,vregs2
       li   r2,8
bitmap_mode_1:
       movb *r1+,@r0lb
       bl   @vwtr                      ; Set register
       ai   r0,>0100
       dec  r2
       jne  bitmap_mode_1
*      Name table
       li   r0,nametb
       bl   @vwad
       clr  r1
       li   r2,>300
bitmap_mode_2:
       movb r1,*r15
       ai   r1,>0100
       dec  r2
       jne  bitmap_mode_2
*      Sprite attributes
       li   r0,spratb
       li   r1,>d000
       bl   @vsbw
*      Return
       .endproc
*      VDP registers
vregs2:
       byte >02                        ; Graphics II mode
       byte >e2                        ; 16K, display on, interrupt enabled
       byte nametb/>400                ; Name table
       byte >ff                        ; Color table
       byte ptrntb/>800+>03            ; Pattern table
       byte spratb/>80                 ; Sprite attribute table
       byte sprptb/>800                ; Sprite pattern table
       byte >01                        ; Backdrop color
*// bitmap_mode

*********************************************************************
*
* VDP Write To Register
*
* R0 MSB: VDP register to write to
* R0 LSB: Value to write
*
vwtr:
       swpb r0
       movb r0,@vdpwa                  ; Send low byte (value) to write to VDP register
       swpb r0
       ori  r0,>8000                   ; Set up a VDP register write operation (10)
       movb r0,@vdpwa                  ; Send high byte (address) of VDP register
       b    *r11
*// vwtr

*********************************************************************
*
* VDP Set Write Address
*
* R0: Write address in VDP RAM
*
* R0 is modified, but can be restored with: ANDI R0,>3FFF
*
vwad:
       swpb r0
       movb r0,@vdpwa                  ; Send low byte of VDP RAM write address
       swpb r0
       ori  r0,>4000                   ; Set read/write bits 14 and 15 to write (01)
       movb r0,@vdpwa                  ; Send high byte of VDP RAM write address
       b    *r11
*// vwad

*********************************************************************
*
* VDP Single Byte Read
*
* R0   Read address in VDP RAM
* R1   MSB of R1 set to byte from VDP RAM
*
vsbr:
       swpb r0
       movb r0,@vdpwa                  ; Send low byte of VDP RAM write address
       swpb r0
       movb r0,@vdpwa                  ; Send high byte of VDP RAM write address
       movb @vdprd,r1                  ; Read byte from VDP RAM
       b    *r11
*// vsbr

*********************************************************************
*
* VDP Single Byte Write
*
* R0: Write address in VDP RAM
* R1: MSB of R1 sent to VDP RAM
*
* R0 is modified, but can be restored with: ANDI R0,>3FFF
*
vsbw:
       swpb r0
       movb r0,@vdpwa                  ; Send low byte of VDP RAM write address
       swpb r0
       ori  r0,>4000                   ; Set read/write bits 14 and 15 to write (01)
       movb r0,@vdpwa                  ; Send high byte of VDP RAM write address
       movb r1,*15                     ; Write byte to VDP RAM
       b    *r11
*// vsbw

***************************************************************************
*
* VDP Multiple Byte Read
*
* R0: Starting read address in VDP RAM
* R1: Starting write address in CPU RAM
* R2: Number of bytes to read from VDP RAM
*
* Modifies R0-R2
*
vmbr:
       swpb r0
       movb r0,@vdpwa                  ; Send low byte of VDP RAM write address
       swpb r0
       movb r0,@vdpwa                  ; Send high byte of VDP RAM write address
vmbr0:
       li   r0,vdprd
vmbr1:
       movb *r0,*r1+                   ; Read byte from VDP RAM
       dec  r2                         ; Byte counter
       jne  vmbr1                      ; Check if finished
       b    *r11
*// vmbr

*********************************************************************
*
* Fast CPU to VDP copy, replaces VMBW
*
* R0: Destination address
* R1: Source address
* R2: Number of bytes to copy
*
* Modifies r0-r3
*
vdpcp:
       swpb r0
       movb r0,@vdpwa                  ; Send low byte of VDP RAM write address
       swpb r0
       ori  r0,>4000                   ; Set the two MSbits to 01 for write
       movb r0,@vdpwa                  ; Send high byte of VDP RAM write address
vdpcp0:
       mov  r2,r3
       srl  r3,3                       ; Number of groups of 8
       jeq  vdpcp2
vdpcp1:
       movb *r1+,*r15
       movb *r1+,*r15
       movb *r1+,*r15
       movb *r1+,*r15
       movb *r1+,*r15
       movb *r1+,*r15
       movb *r1+,*r15
       movb *r1+,*r15
       dec  r3
       jne  vdpcp1
       andi r2,>0007                   ; Isolate number of remaining bytes
       jeq  vdpcp3
vdpcp2:
       movb *r1+,*r0
       dec  r2
       jne  vdpcp2
vdpcp3:
       rt
*// vdpcp

*********************************************************************
*
* Fast CPU to VDP write, replaces VSMW
*
* R0: Destination address
* R1: Byte to write in MSB
* R2: Number of bytes to copy
*
* Modifies r0-r3
*
vdpwr:
       swpb r0
       movb r0,@vdpwa                  ; Send low byte of VDP RAM write address
       swpb r0
       ori  r0,>4000                   ; Set the two MSbits to 01 for write
       movb r0,@vdpwa                  ; Send high byte of VDP RAM write address
       mov  r2,r3
       srl  r3,3                       ; Number of groups of 8
       jeq  vdpwr2
vdpwr1:
       movb r1,*r15
       movb r1,*r15
       movb r1,*r15
       movb r1,*r15
       movb r1,*r15
       movb r1,*r15
       movb r1,*r15
       movb r1,*r15
       dec  r3
       jne  vdpwr1
       andi r2,>0007                   ; Isolate number of remaining bytes
       jeq  vdpwr3
vdpwr2:
       movb r1, *r0
       dec  r2
       jne  vdpwr2
vdpwr3:
       rt
*// vdpwr

***************************************************************************
*
* Wait for key press
*
wait_key:
       .proc
wait_key_1:
       bl   @check_quit
       bl   @any_key
       jne  wait_key_2
*       bl   @vsync
*       bl   @play_sound
       jmp  wait_key_1
*      Return
wait_key_2:
       .endproc
*// wait_key

***************************************************************************
*
* Check quit
*
check_quit:
       clr  r1                         ; Test column 0
       li   r12,>0024                  ; Address for column selection
       ldcr r1,3                       ; Select column
       li   r12,>0006                  ; Address to read rows
       stcr r1,8
       andi r1,>1100
       jeq  quit
*      Return
       rt
*      Quit
quit   clr  @>83c4                     ; Reset user ISR address
       blwp @>0000
*// check_quit

***************************************************************************
*
* Check key
*
* r0: Column in MSB: >0000 - >0700, Row in LSB: >0006 - >0014
*
*       Column   0      1    2    3    4    5     6       7
*     Row
*     >0006      =      .    ,    M    N    /    Fire    Fire
*     >0008    Space    L    K    J    H    ;    Left    Left
*     >000A    Enter    O    I    U    Y    P    Right   Right
*     >000C             9    8    7    6    0    Down    Down
*     >000E    Fctn     2    3    4    5    1    Up      Up
*     >0010    Shift    S    D    F    G    A
*     >0012    Ctrl     W    E    R    T    Q
*     >0014             X    C    V    B    Z
*
* On return NEQ means that the key is pressed
*
KEY_FI EQU  >0606
KEY_LF EQU  >0608
KEY_RG EQU  >060A
KEY_DN EQU  >060C
KEY_UP EQU  >060E
KEY_CM EQU  >0206
KEY_FS EQU  >0106
KEY_0  EQU  >050C
KEY_1  EQU  >050E
KEY_2  EQU  >010E
KEY_3  EQU  >020E
KEY_4  EQU  >030E
KEY_5  EQU  >040E
KEY_6  EQU  >040C
KEY_7  EQU  >030C
KEY_8  EQU  >020C
KEY_9  EQU  >010C
KEY_A  EQU  >0510
KEY_B  EQU  >0414
KEY_C  EQU  >0214
KEY_D  EQU  >0210
KEY_E  EQU  >0212
KEY_F  EQU  >0310
KEY_G  EQU  >0410
KEY_H  EQU  >0408
KEY_I  EQU  >020A
KEY_J  EQU  >0308
KEY_K  EQU  >0208
KEY_L  EQU  >0108
KEY_M  EQU  >0306
KEY_N  EQU  >0406
KEY_O  EQU  >010A
KEY_P  EQU  >050A
KEY_Q  EQU  >0512
KEY_R  EQU  >0312
KEY_S  EQU  >0110
KEY_T  EQU  >0412
KEY_U  EQU  >030A
KEY_V  EQU  >0314
KEY_W  EQU  >0112
KEY_X  EQU  >0114
KEY_Y  EQU  >040A
KEY_Z  EQU  >0514
KEY_SP EQU  >0008
KEY_EN EQU  >000A
KEY_FN EQU  >000E
KEY_SH EQU  >0010
KEY_CT EQU  >0012
*
check_key:
       li   r12,>0024                  ; CRU address of the column decoder
       ldcr r0,3                       ; Select column
       andi r0,>00ff
       mov  r0,r12                     ; Select row
       tb   0                          ; Test key, EQ if not pressed
       rt
*// check_key

*********************************************************************
*
* Resets EQ (neq) if any key is pressed
*
any_key:
*      Check Ctrl
       li   r0,KEY_SH                  ; Shift
       li   r12,>0024                  ; CRU address of the column decoder
       ldcr r0,3                       ; Select column
       andi r0,>00ff
       mov  r0,r12                     ; Select row
       tb   0                          ; Test key, EQ if not pressed
       jeq  any_key_0
       c    r0,r0                      ; Set eq
       jmp  any_key_4
*      Check all columns
any_key_0:
       li   r1,>0000                   ; Column
any_key_1:
       li   r12,>0024                  ; CRU address of the column decoder
       mov  r1,r0
       swpb r0
       ldcr r0,3                       ; Select column
       li   r12,0006                   ; Select row
       stcr r0,8
       seto r2
       cb   r0,r2                      ; If any bit is reset a key is pressed
       jne  any_key_2
       inc  r1
       ci   r1,8
       jne  any_key_1
       jmp  any_key_4                  ; eq ok
any_key_2:
       ci   r1,6
       jne  any_key_3                  ; neq ok
*       inc  @user_input_device         ; Still neq
       jmp  any_key_4
any_key_3:
*       clr  @user_input_device         ; Sets eq
       seto r0                         ; Reset eq
       jmp  any_key_4
any_key_4:
       rt
*// any_key

*********************************************************************
*
* Data
*
byte_ff:
       byte >ff
byte_fe:
       byte >fe
byte_fc:
       byte >fc
byte_fb:
       byte >fb
byte_f5:
       byte >f5
byte_f4:
       byte >f4
byte_f3:
       byte >f3
byte_de:
       byte >de
byte_01:
       byte >01

       copy "rooms.a99"
       copy "room-object-slots.a99"
       copy "furniture.a99"
       copy "scoreboard-item.a99"
       copy "bmp-tiles.a99"
       copy "bmp-milk.a99"
       copy "bmp-wally.a99"
       copy "bmp-objects.a99"
       copy "object-text.a99"
       copy "object-flags.a99"
       copy "food-table.a99"
       copy "object-found-table.a99"

       end  main
