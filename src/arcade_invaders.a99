*********************************************************************
*
* Game loop for Invaders game room
*
invaders_loop:
       bl   @vsync
       bl   @wally_draw
       bl   @wally_handler
       bl   @wally_step_check
       mov  @invaders_left,r0
       ci   r0,6
       jl   invaders_loop_1
       li   r0,6
invaders_loop_1:
       mov  r0,@invaders_updates
invaders_loop_2:
       bl   @invaders_update
       dec  @invaders_updates
       jne  invaders_loop_2
       bl   @invaders_update_explosions
       bl   @invaders_exit_check
       bl   @invaders_bullet_update
       bl   @invaders_update_bombs
       bl   @wally_check_for_death
       bl   @game_exit_check
       bl   @upload_sprites
       inc  @frame
       jmp  invaders_loop
*// invaders_loop

*********************************************************************
*
* Initialise invaders
*
invaders_init:
       .proc
       mov  @invaders_type_ptr,r0
       ai   r0,-invaders_first_type
       srl  r0,1
       ai   r0,>1d
       mov  r0,@wally_room_no
       bl   @screen_clear_room
       bl   @draw_ceiling_wall_floor
       li   r0,>0f00
       li   r1,LDC31
       bl   @furniture_draw
       li   r0,invaders_data
       mov  r0,@invaders_data_ptr
invaders_init_0:
       mov  @invaders_data_ptr,r0
       mov  *r0+,r1
       ci   r1,>ffff
       jeq  invaders_init_1
       mov  r0,@invaders_data_ptr
       movb r1,@bitmap_x+1
       movb @r1lb,@bitmap_y+1
       mov  @invaders_current_frame,r0
       bl   @bitmap_16_draw
       jmp  invaders_init_0
invaders_init_1:
       li   r0,invaders_data
       mov  r0,@invaders_data_ptr
;      TODO
;F384	LD HL,Arcade_ExplosionSlots	Reset all explosion animations to 'not active'.
;Invaders_Init_4
;F387	LD A,(HL)	Check for end of data marker.
;F388	CP $FE
;F38A	JR Z,Invaders_Init_5
;F38C	LD (HL),$FF
;F38E	INC HL
;F38F	INC HL
;F390	INC HL
;F391	JR Invaders_Init_4
;Invaders_Init_5
;F393	LD B,$03	Number of possible bombs.
;F395	LD HL,Arcade_BombData	Reset all bombs to 'not active'.
;Invaders_Init_6
;F398	LD (HL),$FF
;F39A	INC HL
;F39B	INC HL
;F39C	INC HL
;F39D	DJNZ Invaders_Init_6

       .endproc
*// invaders_init

*********************************************************************
*
* Initialise invaders x positions
*
invaders_init_x_pos:
       .proc
       li   r0,invaders_data           ; Start with top row, left hand column.
       li   r1,>0a00                   ; Left hand position.
       li   r2,8                       ; 8 columns.
invaders_init_x_pos_0:
       movb r1,*r0                     ; Top.
       inct r0
       movb r1,*r0                     ; Middle.
       inct r0
       movb r1,*r0                     ; Bottom.
       inct r0
       ai   r1,>1800                   ; Next column position.
       dec  r2
       jne  invaders_init_x_pos_0      ; Next column.
       clr  @invaders_change_dir_flag
       li   r0,1                       ; Reset direction to right.
       mov  r0,@invaders_current_dir
       li   r0,>0018
       mov  r0,@invaders_left
       .endproc
*// invaders_init_x_pos

*********************************************************************
*
* Initialise invaders y positions
*
invaders_init_y_pos:
       .proc
;      TODO
       li   r0,invaders_data+1	       ; Start with top row, left hand column for 8 columns.
       li   r1,>3800
       li   r3,>5800
       li   r4,>7800
       li   r2,8
invaders_init_y_pos_0:
       movb r1,*r0                     ; Top.
       inct r0
       movb r3,*r0                     ; Middle.
       inct r0
       movb r4,*r0                     ; Bottom.
       inct r0
       dec  r2
       jne  invaders_init_y_pos_0      ; Next column.
       .endproc
*// invaders_init_y_pos

*********************************************************************
*
* Draw invaders, drop bombs
*
invaders_update:
       .proc
;      TODO
       mov  @invaders_data_ptr,r4      ; Start of data.
invaders_update_0:
       mov  *r4+,r1                    ; Get x and y
       cb   r1,@byte_fe                ; See if valid
       jeq  invaders_update_0          ; If not valid, move onto next invader.
invaders_update_1:
       ci   r1,>ffff                   ; Check for end of data.
       jne  invaders_update_3          ; If not the go on to handle invader.
*      End of data
       li   r4,invaders_data           ; Reset start of first invader.
       mov  r4,@invaders_data_ptr
       mov  @invaders_current_frame,r0 ; Update frame to the next one.
       mov  r0,@invaders_next_frame
       inc  r0                         ; Update to next frame.
       c    r0,@invaders_end_frame     ; See if frame has reached end frame.
       jne  invaders_update_2
       mov  @invaders_start_frame,r0   ; Reset to start if so.
invaders_update_2:
       mov  r0,@invaders_current_frame ; Store updated frame.
       mov  @invaders_change_dir_flag,r0
       a    r0,r0
       mov  r0,@invaders_flag
       jeq  invaders_update_11         ; Return
       clr  @invaders_change_dir_flag  ; Reset flag.
       neg  @invaders_current_dir      ; Change direction.
       jmp  invaders_update_11         ; Return
*      Not end of data
invaders_update_3:
       mov  r4,@invaders_data_ptr      ; Set pointer to next invader.
       dect r4                         ; Push address back to current invader.
       movb r1,@bitmap_x+1             ; Set draw to position.
       movb @r1lb,@bitmap_y+1
       ab   @invaders_current_dir+1,r1 ; Get direction and update X position in direction.
       cb   r1,@byte_e8                ; Check for right hand end of screen reached.
       jne  invaders_update_5
invaders_update_4:
       li   r0,1                       ; If reached, change direction for all invaders.
       mov  r0,@invaders_change_dir_flag
       jmp  invaders_update_6
invaders_update_5:
       cb   r1,@byte_08                ; Check for left hand end of screen reached.
       jeq  invaders_update_4          ; Change direction if so.
invaders_update_6:
       ab   @invaders_flag,@r0lb       ; Add flag? to y
       cb   @r0lb,@byte_a0             ; Reached bottom?
       jl   invaders_update_7
       movb @byte_01,@death_flag       ; Die
invaders_update_7:
       mov  r1,*r4                     ; Save updated position
*      Draw invader
       .push r1
       bl   @bitmap_16_erase            ; Erase invader from old position
       .pop r1
       mov  @invaders_next_frame,r0
       movb r1,@bitmap_x+1             ; Draw invader at new position and new frame.
       movb @r1lb,@bitmap_y+1
       .push r1
       bl   @bitmap_16_draw
       .pop r1
       swpb r1
       li   r0,2                       ; Check for hitting Wally.
       bl   @wally_hit_test

;F42E	LD HL,(BitmapX)	Get position again.
;F431	LD A,R	Create a random number.
;F433	CP $08	If great or equal to 8 then end.
;F435	RET NC
;*      Drop a bomb.
;F436	EX DE,HL
;F437	LD B,$03	number of bombs.
;F439	LD HL,Arcade_BombData	Start of bomb data.
;*      Bombs, look for an empty slot.
;invaders_update_8:
;F43C	LD A,(HL)	Get x position.
;F43D	CP $FF	See if bomb is active.
;F43F	JR Z,invaders_update_9	If not, create one.
;F441	INC HL	If so, move onto next bomb.
;F442	INC HL
;F443	INC HL
;F444	DJNZ invaders_update_8
;F446	RET
;*      Bomb, empty slot found.
;invaders_update_9:
;F447	LD (HL),E	Store position.
;F448	INC HL
;F449	LD (HL),D
;F44A	INC HL
;F44B	EX DE,HL
;F44C	LD HL,$F45D	Get the next bitmap within the range of ($c0 ~ $c6)
;F44F	INC (HL)
;F450	LD A,(HL)
;F451	CP $C7
;F453	JR NZ,invaders_update_10
;F455	LD A,$C0
;F457	LD (HL),A
;invaders_update_10:
;F458	LD (DE),A	Store the frame for this bomb.
;F459	CALL Bitmap16Draw	Draw bomb.

invaders_update_11:
       .endproc
*// invaders_update

*********************************************************************
*
* Update explosions in the Arcade Room
*
invaders_update_explosions:
       .proc
       li   r5,invaders_explosion_slots
invaders_update_explosions_0:
       mov  *r5,r4
       jeq  invaders_update_explosions_1
       ci   r4,>ffff
       jeq  invaders_update_explosions_2
       mov  @2(r5),r0                  ; Get animationn frame
       inc  r0
       ci   r0,>00a5
       jeq  invaders_update_explosions_3
       mov  r0,@2(r5)
       bl   @get_sprite_pattern
       movb r1,@sprite_pattern(r4)
       jmp  invaders_update_explosions_1
invaders_update_explosions_3:
       mov  r4,r0
       bl   @deallocate_sprite
       clr  *r5
invaders_update_explosions_1:
       ai   r5,4
       jmp  invaders_update_explosions_0
invaders_update_explosions_2:
       .endproc
*// invaders_update_explosions

*********************************************************************
*
* Check to see if Wally has left the arcade room
*
invaders_exit_check:
       .proc
       movb @wally_x,r0                ; See if Wally is at the far left of the room.
       sb   @byte_09,r0
       cb   r0,@byte_fe
       jl   invaders_exit_check_1      ; Do nothing if not.
       li   r0,>0015
       mov  r0,@wally_room_no          ; Move into the next room and update.
       li   r0,>98d0
       mov  r0,@wally_y
       bl   @room_enter
       li   r10,stack+2                ; Reset stack
       movb @byte_00,@is_arcade_mode
       b    @game_loop                 ; Go back to normal game play.
invaders_exit_check_1:
       .endproc
*// invaders_exit_check

*********************************************************************
*
* Invaders: Bullet Update
*
invaders_bullet_update:
       .proc
;      TODO
       mov  @invaders_bullet_sprite,r4 ; See if a bullet exists, if not then do nothing.
       jeq  invaders_bullet_update_4
       li   r7,invaders_data           ; Run through the data of each invader.
       li   r6,>18
invaders_bullet_update_1:
       mov  *r7+,r1                    ; Get x and y
       cb   r1,@byte_fe                ; Only do anything if invader is active.
       jne  invaders_bullet_update_3   ; If it is check for collision.
invaders_bullet_update_2:
       dec  r6
       jne  invaders_bullet_update_1   ; Move onto next invaders.
*      Update bullet
       sb   @byte_03,*r4               ; Decrease Y pos by three pixels.
       cb   *r4,@byte_30               ; See if at top of screen.
       jhe  invaders_bullet_update_4   ; Return
*      Disable bullet
       mov  r4,r0
       bl   @deallocate_sprite
       clr  @invaders_bullet_sprite
       jmp  invaders_bullet_update_4   ; Return
*      Check collision with invader
invaders_bullet_update_3:
       mov  r1,r0                      ; Copy position of invader
       swpb r0
       sb   *r4,r0                     ; Check against Y position of bullet.
       sb   @byte_10,r0
       cb   r0,@byte_e0
       jl   invaders_bullet_update_2   ; Next invader if not.
       swpb r0
       sb   @1(r4),r0                  ; Check against X position of bullet.
       sb   @byte_10,r0
       cb   r0,@byte_e0
       jl   invaders_bullet_update_2   ; Next invader if not.
*      Hit
       mov  r4,r0
       bl   @deallocate_sprite
       clr  @invaders_bullet_sprite    ; Set bullet as disabled.
       dect r7                         ; Back to current invader
       movb @byte_fe,*r7               ; Set invader as disabled as well.
       movb r1,@bitmap_x+1
       movb @r1lb,@bitmap_y+1
       .push r1
       bl   @bitmap_16_erase           ; Erase invader
       .pop r1
       bl   @invaders_create_explosions
       dec  @invaders_left
       jne  invaders_bullet_update_4
       bl   @invaders_next_stage
invaders_bullet_update_4:
       .endproc
*// invaders_bullet_update

*********************************************************************
*
* Update and draw bombs for the Arcade room
*
invaders_update_bombs:
       .proc
;      TODO
       .endproc
*// invaders_update_bombs

*********************************************************************
*
* Create a 'bullet' if required
*
wally_shoot_create:
       mov  @invaders_bullet_sprite,r0 ; See if a 'bullet' already exists.
       jne  wally_shoot_create_1
       li   r0,>00bf                   ; Knife and Fork
       bl   @get_sprite_pattern
       movb @byte_0e,@r1lb
       mov  r1,r3
       mov  @wally_y,r4
       sb   @byte_08,r4
       bl   @allocate_sprite           ; If not, create one by placing it just above Wally.
       mov  r0,@invaders_bullet_sprite
       mov  r4,*r0+
       mov  r3,*r0
wally_shoot_create_1:
       b    @wally_handler_5
*// wally_shoot_create

*********************************************************************
*
* Create an explosion in the Arcade room
*
* r1: position x MSB, y LSB
*
invaders_create_explosions:
       .proc
       mov  r1,r4
       li   r5,invaders_explosion_slots
invaders_create_explosions_0:
       mov  *r5,r0
       jeq  invaders_create_explosions_1
       ci   r0,>ffff
       jeq  invaders_create_explosions_2
       ai   r5,4
       jmp  invaders_create_explosions_0
invaders_create_explosions_1:
       li   r0,>009f                   ; Bitmap frame
       mov  r0,@2(r5)                  ; Store it
       bl   @get_sprite_pattern
       mov  r1,r3                      ; Pattern
       movb @byte_0b,@r3lb             ; Color yellow
       bl   @allocate_sprite
       mov  r0,*r5
       jeq  invaders_create_explosions_2
       swpb r4                         ; Swap x and y
       mov  r4,*r0+                    ; Set sprite position
       mov  r3,*r0                     ; set sprite pattern and color
invaders_create_explosions_2:
       .endproc
*// invaders_create_explosions

*********************************************************************
*
* Reset everything for next stage.
*
invaders_next_stage:
       .proc
       mov  @invaders_type_ptr,r0      ; See if reached the last stage.
       cb   *r0,@byte_ff               ; If not then reset invaders for next stage.
       jne  invaders_next_stage_1
       mov  @wally_lives,r0
       ci   r0,3                       ; Cap the max number of lives, player ca only have upto three lives.
       jeq  invaders_next_stage_0
       inc  r0                         ; Increase the number of lives and update on screen.
       mov  r0,@wally_lives
       bl   @life_draw_blit
invaders_next_stage_0:
       li   r0,invaders_first_type     ; Go back to first stage again.
invaders_next_stage_1:
       movb *r0+,r1                    ; Reset invaders to current stage / animations.
       movb r1,@invaders_current_frame+1
       movb r1,@invaders_start_frame+1
       ab   @byte_01,r1
       movb r1,@invaders_next_frame+1
       movb *r0+,@invaders_end_frame+1 ; Reset invaders to current stage / animations.
       mov  r0,@invaders_type_ptr      ; Point to the next stage ready for next time level is cleared.
       bl   @invaders_init_x_pos
       bl   @invaders_init_y_pos
       bl   @invaders_init
       bl   @deallocate_sprites
       .endproc
*// invaders_next_stage

*********************************************************************

invaders_data_ptr:
       data invaders_data              ; Points to invader data.
invaders_type_ptr:
       data invaders_first_type+2      ; Points to address holding the current type of invader.
invaders_left:
       data >0018
invaders_updates:
       data >0006
invaders_current_frame:
       data >0075                      ; Current bitmap frame of invaders.
invaders_next_frame:
       data >0076                      ; Next bitmap frame of invaders.
invaders_start_frame:
       data >0075                      ; Start frame of animation.
invaders_end_frame:
       data >007a                      ; End frame of animation.
invaders_current_dir:
       data >0001                      ; Current direction of invaders.
invaders_change_dir_flag:
       data >0000                      ; When set indicates change of direction.
invaders_flag:
       data >0000                      ; Current direction of invaders.
invaders_bomb_frame:
       data >00c0                      ; F45D

invaders_first_type:
       byte >75,>7a                    ; Venus Flytrap
       byte >7B,>7F                    ; Roast Chicken
       byte >93,>99                    ; Angel of Death
       byte >99,>9B                    ; Space Invader
       byte >AD,>B3                    ; Spooky Hand
       byte >B3,>BB                    ; Spinning Axe
       byte >BB,>BF                    ; Ghost
       byte >FF,>FF                    ; End of data.

invaders_data:
       byte >0A,>38                    ; Column 1 [X pos, Y pos]
       byte >0A,>58
       byte >0A,>78
       byte >22,>38                    ; Column 2..
       byte >22,>58
       byte >22,>78
       byte >3A,>38
       byte >3A,>58
       byte >3A,>78
       byte >52,>38
       byte >52,>58
       byte >52,>78
       byte >6A,>38
       byte >6A,>58
       byte >6A,>78
       byte >82,>38
       byte >82,>58
       byte >82,>78
       byte >9A,>38
       byte >9A,>58
       byte >9A,>78
       byte >B2,>38                    ; Column 8
       byte >B2,>58
       byte >B2,>78
       byte >FF,>FF                    ; End of data.

invaders_explosion_slots
       data >0000,>0000                ; Sprite, Frame
       data >0000,>0000
       data >0000,>0000
       data >0000,>0000
       data >0000,>0000
       data >0000,>0000
       data >ffff                      ; End of data.

invaders_bomb_data:                    ; Starting with 'FF' shows an empty slot.
       byte >FF,>00,>00,>00	           ; X, Y, Bitmap
       byte >FF,>00,>00,>00
       byte >FF,>00,>00,>00

invaders_bullet_sprite:
       data >0000
