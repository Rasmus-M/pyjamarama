*********************************************************************
*
* Pyjamarama
* For the TI-99/4A home computer
*
* November 2018
* Rasmus Moustgaard <rasmus.moustgaard@gmail.com>
*
*********************************************************************

       def  main

**
* Assembly options
*
immunity:
       equ  0

**
* Constants
*
start_room:
       equ  1
attr_40:                               ; Black
       equ  >1100
attr_41:                               ; Blue
       equ  >5100
attr_42:                               ; Red
       equ  >8100
attr_43:                               ; Magenta
       equ  >d100
attr_44:                               ; Green
       equ  >2100
attr_45:                               ; Cyan
       equ  >7100
attr_46:                               ; Yellow
       equ  >b100
attr_47:                               ; White
       equ  >f100
sprite_table_size:
       equ  32
sprite_pattern_map_size:
       equ  200
sprite_bitmap_map_size:
       equ  64

**
* Memory mapped addresses
*
vdpwd  equ  >8c00                      ; VDP write data
vdpwa  equ  >8c02                      ; VDP set read/write address
vdprd  equ  >8800                      ; VDP read data
vdpsta equ  >8802                      ; VDP status
sound  equ  >8400

**
* VDP memory map
*
ptrntb equ  >0000                      ; Pattern table base
sprptb equ  >1800                      ; Sprite pattern table base
colrtb equ  >2000                      ; Color table base
nametb equ  >3800                      ; Name table base
spratb equ  >3C00                      ; Sprite attribute table base 1

**
* Structures
*
sprite_y:
       equ  0
sprite_x:
       equ  1
sprite_pattern:
       equ  2
sprite_color:
       equ  3
sprite_size:
       equ  4

**
* Scratch pad
*
rndsd  equ  >83c0                      ; Random number seed
pad    equ  >8300
wrksp  equ  pad                        ; Workspace
r0lb   equ  wrksp+1                    ; r0 low byte required for VDP routines
r1lb   equ  wrksp+3
r2lb   equ  wrksp+5
r3lb   equ  wrksp+7
r4lb   equ  wrksp+9
r5lb   equ  wrksp+11
r6lb   equ  wrksp+13
r7lb   equ  wrksp+15
r8lb   equ  wrksp+17
r9lb   equ  wrksp+19
stack  equ  pad+>20                    ; Stack (grows up)
padvar equ  stack+>10                  ; Start of pad variables
*
* PAD variables
*
start_room_no:
       equ  padvar
wally_room_no:
       equ  start_room_no+2
wally_lives:
       equ  wally_room_no+2
wally_y:
       equ  wally_lives+2
wally_x:
       equ  wally_y+1
wally_attr:
       equ  wally_x+1
wally_attr_alt:
       equ  wally_attr+1
wally_sprite_1:
       equ  wally_attr_alt+1
wally_sprite_2:
       equ  wally_sprite_1+2
wally_shift_value:
       equ  wally_sprite_2+2
wally_char_aligned:
       equ  wally_shift_value+2
wally_last_dir:
       equ  wally_char_aligned+2
wally_head_countdown:
       equ  wally_last_dir+1
input_flag:
       equ  wally_head_countdown+1
pocket_1:
       equ  input_flag+2
pocket_2:
       equ  pocket_1+2
tile_flip_vertical:
       equ  pocket_2+2
tile_start_ptr:
       equ  tile_flip_vertical+2
bitmap_x:
       equ  tile_start_ptr+2
bitmap_y:
       equ  bitmap_x+2
food_active_ptr:
       equ  bitmap_y+2
max_sprite:
       equ  food_active_ptr+2
rand_no:
       equ  max_sprite+2
pad_max:
       equ  rand_no+2

**
* Macros
*
       .defm proc
       mov  r11,*r10+
       .endm

       .defm endproc
       dect r10
       mov  *r10,r11
       b    *r11
       .endm

*********************************************************************
*
* Main program
*
       aorg >a000
main:
       limi 0                          ; Interrupts off
       lwpi wrksp                      ; Setup workspace
       li   r10,stack                  ; Setup stack pointer
       bl   @one_time_init
loop:  bl   @game_start
       mov  @start_room_no,r0
       inc  r0
       ci   r0,30
       jlt  !
       clr  r0
!      mov  r0,@start_room_no
       jmp  loop

*********************************************************************
*
* One time initializations
*
one_time_init:
       .proc
       mov  @rndsd,@rand_no            ; Save random number seed
       li   r15,vdpwd                  ; Do not change
*      Graphics mode
       bl   @bitmap_mode
*      Scratch pad variables
       li   r0,padvar
       li   r2,pad_max-padvar
one_time_init_1:
       clr  *r0+
       dect r2
       jne  one_time_init_1
       li   r0,start_room
       mov  r0,@start_room_no
       seto @input_flag
       .endproc
*// one_time_init

*********************************************************************
*
* Start a new game
*
game_start:
       .proc
       mov  @start_room_no,@wally_room_no
       bl   @screen_clear
       bl   @init_sprites
       bl   @game_init_stats
       bl   @room_draw
       li   r0,>0001
       li   r1,scoreboard_item
       bl   @furniture_draw
       bl   @inventory_redraw
       bl   @lives_reset
       bl   @milk_draw_full
       li   r0,>9858
       mov  r0,@wally_y
game_loop:
       bl   @vsync
       bl   @vsync
       bl   @wally_draw
       bl   @wally_handler
       bl   @room_event_handler
       bl   @upload_sprites
       bl   @check_quit
       li   r0,KEY_SH
       bl   @check_key
       jeq  game_loop
game_end:
       .endproc
*// game_start

*********************************************************************
*
* Wait for vertical retrace
*
vsync:
       movb @vdpsta,r12
vsync_1:
       movb @vdpsta,r12
       jgt  vsync_1
       jeq  vsync_1
       b    *r11
*// vsync

*********************************************************************
*
* Main handler for moving Wally around
*
wally_handler:
       .proc
       mov  @wally_y,r0                ; Get current position, shift to 1 cell across and 4 rows down. Under the feet of Wally.
       ab   @byte_08,@r0lb
       ab   @byte_20,r0
       bl   @get_attribute             ; Get the background colour at that point and store.
       movb r0,@wally_attr
       abs  @wally_char_aligned        ; See if Wally is aligned with the character cell row at current position.
       jne  wally_handler_0
       ai   r1,-32                     ; One row up
       movb *r1,@wally_attr_alt
       jmp  wally_handler_1
wally_handler_0:
       movb r0,@wally_attr_alt         ; Store this for both flags.
*      Check Wally's state
wally_handler_1:
       movb @is_arcade_mode,r0         ; See if game is in Arcade mode, which means no jumping or falling.
       jne  wally_handler_2
       movb @wally_jump_dir,r0         ; See if Wally is currently in a jump.
       jne  wally_jump_handler_entry
wally_handler_2:
       movb @wally_falling,r0	       ; See if Wally is falling.
       jne  wally_check_fall
       movb @wally_attr,r0             ; See if Wally is not on a platform and needs to start falling.
       cb   r0,@byte_attr_45           ; Cyan
       jeq  wally_handler_3
       cb   r0,@byte_attr_42           ; Red
       jeq  wally_handler_3
       movb @byte_01,@wally_falling
       jmp  wally_check_fall
*      Check user's input
wally_handler_3:
*      Jump
       abs @input_flag
       jeq  wally_handler_4
*      Joystick
       li   r0,JOY_FI
       bl   @check_key
       jne  wally_jump
       jmp  wally_handler_5
wally_handler_4:
*      Keyboard
       li   r0,KEY_SP
       bl   @check_key
       jne  wally_jump
wally_handler_5:
       movb @byte_00,@wally_dir
       abs  @input_flag
       jeq  wally_handler_6
       li   r0,JOY_RT
       bl   @check_key
       jne  wally_handler_7
       jmp  wally_handler_8
Wally_Handler_6:
       li   r0,KEY_D
       bl   @check_key
       jeq  wally_handler_8
Wally_Handler_7:
       li   r0,>0100
       movb r0,@wally_dir
       movb r0,@wally_last_dir
       b    @wally_move
Wally_Handler_8:
       abs  @input_flag
       jeq  wally_handler_9
       li   r0,JOY_LT
       bl   @check_key
       jne  wally_handler_10
       jmp  wally_handler_end
Wally_Handler_9:
       li   r0,KEY_S
       bl   @check_key
       jeq  wally_handler_end
Wally_Handler_10:
       li   r0,->0100
       movb r0,@wally_dir
       movb r0,@wally_last_dir
       b    @wally_move

*      Check to see if Wally is standing on solid ground
wally_check_fall:
       movb @wally_attr,r0
       cb   r0,@byte_attr_42           ; Red
       jeq  wally_check_attr_solid
       cb   r0,@byte_attr_45           ; Cyan
       jne  wally_check_fall_0
wally_check_attr_solid:
;      movb @wally_y,r0                ; See if Wally is aligned with a character cell.
;      andi r0,>0700
       mov  @wally_char_aligned,r0
       jne  wally_check_fall_0         ; If not then let him fall regardless of colour.
       movb @byte_00,@wally_falling
       jmp  wally_handler_end
wally_check_fall_0:
       ab   @byte_04,@wally_y
wally_handler_end:
       .endproc

wally_jump:
       nop
wally_jump_handler_entry:
       nop
       .endproc

wally_move:
;      bl   @enegy_countdown           ; TODO
       movb @wally_dir,r0
       cb   r0,@byte_01
       jeq  wally_move_right
*      Wally Move Left
wally_move_left:
       movb @wally_frame,r0
       bl   @wally_turn_head
       cb   r0,@byte_00
       jhe  wally_move_1
wally_move_0:
       movb @byte_00,@wally_head_turned ; Clear head turn flag (1)
       movb @byte_00,r0
       jmp  wally_move_2
wally_move_1:
       ab   @byte_02,r0
       cb   r0,@byte_10
       jhe  wally_move_0
wally_move_2:
       movb r0,@wally_frame            ; Store new frame.
       movb @wally_x,r0                ; Get x position
       sb   @byte_02,r0                ; Move Wally left
       cb   r0,@byte_07
       jhe  wally_move_3               ; Don't let him move off the left hand side of screen.
       movb @byte_07,r0
wally_move_3:
       movb r0,@wally_x
       jmp  wally_move_8
*      Wally Move Right.
wally_move_right:
       movb @wally_frame,r0
       bl   @wally_turn_head
       cb   r0,@byte_10
       jhe  wally_move_5
wally_move_4:
       movb @byte_00,@wally_head_turned ; Clear head turn flag (2)
       movb @byte_10,r0
       jmp  wally_move_6
wally_move_5:
       ab   @byte_02,r0
       cb   r0,@byte_20
       jhe  wally_move_4
wally_move_6:
       movb r0,@wally_frame            ; Store new frame.
       movb @wally_x,r0                ; Get x position
       ab   @byte_02,r0
       cb   r0,@byte_e9
       jl   wally_move_7
       movb  @byte_e9,r0
wally_move_7:
       movb r0,@wally_x
wally_move_8:
       .endproc
*// wally_handler

*********************************************************************
*
* Checks to see if Wally should turn his head towards the camera
*
* Input:
* r0: Current frame to test against
*
wally_turn_head:
       .proc
       mov r0,*r10+
       cb   r0,@byte_00
       jeq  wally_turn_head_2
       cb   r0,@byte_10
       jeq  wally_turn_head_2
       cb   r0,@byte_0c
       jeq  wally_turn_head_1
       cb   r0,@byte_1c
       jeq  wally_turn_head_1
       movb @wally_head_countdown,r0  ; If counter is greater than zero, skip onto just counting down.
       jne  wally_turn_head_3
       jmp  wally_turn_head_4
wally_turn_head_1:
       movb @wally_head_countdown,r0  ; If counter is greater than zero, skip onto just counting down.
       jne  wally_turn_head_3
       movb r0,@wally_head_turned      ; Clear Wally's head turn flag(2).
       bl   @rand                      ; Set a random value (0 ~ 1F) into countdown.
       andi r0,>1f00
       movb r0,@wally_head_countdown
       jmp  wally_turn_head_4
wally_turn_head_2
       movb @wally_head_countdown,r0  ; If counter is greater than zero, skip onto just counting down.
       jne  wally_turn_head_3
       movb @byte_01,@wally_head_turned
       jmp  wally_turn_head_4
wally_turn_head_3:
       sb   @byte_01,r0
       movb r0,@wally_head_countdown
wally_turn_head_4:
       dect r10
       mov  *r10,r0
       .endproc
*// wally_turn_head

*********************************************************************
*
* Calls the event for the current room
*
room_event_handler:
       .proc
       mov  @wally_room_no,r1          ; Calculate address of jump vector (room*2) + vectors.
       sla  r1,1
       mov  @room_update_vectors(r1),r1
       bl   *r1
       .endproc
*// room_event_handler

*********************************************************************
*
* Initialize game data
*
game_init_stats:
       .proc
       li   r0,>0000                   ; The Round Key
       mov  r0,@pocket_1
       li   r0,>0001                   ; The Radio
       mov  r0,@pocket_2
       li   r0,food_table              ; Reset active food
       mov  r0,@food_active_ptr
*      Clear all the object flags
       li   r2,>16                      .
       li   r0,lift_count
game_init_stats_0:
       clr  *r0+
       dect r2
       jne  game_init_stats_0
*      Reset object positions by filling in the object slots, for each room, with and object index in incremental steps
       li   r0,room_obj_slot_Obj
       li   r2,>1e
       li   r1,>0200
game_init_stats_1:
       movb r1,*r0+
       inct r0
       ai   r1,>0100
       dec  r2
       jne  game_init_stats_1
*      Clear all object found markers
       li   r0,object_found_table      ;
       li   r2,>20
       clr  r1
game_init_stats_2:
       movb r1,*r0
       inct r0
       dec  r2
       jne  game_init_stats_2
*      Clear all rooms visited
       li   r2,>23
game_init_stats_3:
       movb r1,*r0+
       dec  r2
       jne  game_init_stats_3
*      Allocate sprites for Wally
       bl   @allocate_sprite
       mov  r0,@wally_sprite_1
       ai   r0,3
       movb @byte_0b,*r0
       bl   @allocate_sprite
       mov  r0,@wally_sprite_2
       ai   r0,3
       movb @byte_0b,*r0
       .endproc
*// game_init_stats

*********************************************************************
*
* Reset lives
*
lives_reset:
       .proc
       li   r0,3
       mov  r0,@wally_lives
       li   r0,3
lives_reset_1:
       mov  r0,*r10+                   ; Push r0
       bl   @life_draw_blit
       dect r10                        , Pop r0
       mov  *r10,r0
       dec  r0
       jne  lives_reset_1
       .endproc
*// lives_reset

*********************************************************************
*
* Redraw inventory area
*
inventory_redraw:
       .proc
       bl   @inventory_clear
       li   r0,bmp_tiles               ; Reset the start address of the tiles back to tile zero
       mov  r0,@tile_start_ptr
       mov  @pocket_1,r1
       sla  r1,1
       mov  @object_text_ptr_table(r1),r0
       li   r1,>0014
       li   r2,attr_44
       bl   @inventory_draw_text
       mov  @pocket_2,r1
       sla  r1,1
       mov  @object_text_ptr_table(r1),r0
       li   r1,>0214
       li   r2,attr_45
       bl   @inventory_draw_text
       mov  @pocket_1,r0
       ai   r0,>50
       li   r1,>0088
       mov  r1,@bitmap_x
       clr  @bitmap_y
       bl   @bitmap_16_draw
       mov  @pocket_2,r0
       ai   r0,>50
       li   r1,>0010
       mov  r1,@bitmap_y
       bl   @bitmap_16_draw
       .endproc
*// inventory_redraw

*********************************************************************
*
* Clear inventory area
*
inventory_clear:
       .proc
       li   r0,17*8
       li   r2,4
inventory_clear_1:
       bl   @vwad
       li   r3,15*8
inventory_clear_2:
       clr  *r15
       dec  r3
       jne  inventory_clear_2
       ai   r0,256
       dec  r2
       jne  inventory_clear_1
       .endproc
*// inventory_clear

*********************************************************************
*
* Draws the text for an object in a pocket
*
* Input:
*
* r0: Address of text string
* r1 MSB: y position
* r1 LSB: x position
* r2 MSB: color
*
inventory_draw_text:
       .proc
       mov  r0,r4
inventory_draw_text_7:
       movb *r4+,r0
       jgt  inventory_draw_text_0
       cb   r0,@byte_ff
       jeq  inventory_draw_text_1
       cb   r0,@byte_fc
       jne  inventory_draw_text_0
       ab   *r4+,@r1lb
       ab   *r4+,r1
       jmp  inventory_draw_text_7
inventory_draw_text_0:
       mov  r1,*r10+
       bl   @tile_draw
       dect r10
       mov  *r10,r1
       inc  r1
       jmp  inventory_draw_text_7
inventory_draw_text_1:
       movb *r4,r0
       cb   r0,@byte_fa
       jne  inventory_draw_text_8
       ci   r2,attr_44
       jne  inventory_draw_text_2
       mov  @pocket_1,r3
       jmp  inventory_draw_text_3
inventory_draw_text_2:
       mov  @pocket_2,r3
inventory_draw_text_3:
       ci   r3,>0d
       jne  inventory_draw_text_4
       li   r3,flag_laser_gun
       jmp  inventory_draw_text_6
inventory_draw_text_4:
       ci   r3,>08
       jne  inventory_draw_text_5
       li   r3,flag_fuel_can
       jmp  inventory_draw_text_6
inventory_draw_text_5:
       li   r3,flag_water_bucket
inventory_draw_text_6:
       inc  r1
       li   r4,txt_full
       li   r2,>a100
       movb *r3,r5
       jne  inventory_draw_text_7
       li   r4,txt_empty
       jmp  inventory_draw_text_7
inventory_draw_text_8:
       .endproc
txt_full:
       text "FULL"
       byte >ff
txt_empty:
       text "EMPTY"
       byte >ff
       even
*// inventory_draw_text

*********************************************************************
*
* Draw Wally
*
wally_draw:
       .proc
*      Head
       mov  @wally_sprite_1,r4
       movb @wally_y,*r4+
       movb @wally_x,*r4+
       clr  r0
       movb @wally_frame,@r0lb
       movb @wally_head_turned,r1
       jeq  wally_draw_1
       ci   r0,>0010
       jhe  wally_draw_0
       ai   r0,>003e
       jmp  wally_draw_1
wally_draw_0:
       ai   r0,>002f
wally_draw_1:
       bl   @get_sprite_pattern
       movb r1,*r4+
*      Feet
       mov  @wally_sprite_2,r4
       movb @wally_y,r0
       ai   r0,>1000
       movb r0,*r4+
       movb @wally_x,*r4+
       clr  r0
       movb @wally_frame,@r0lb
       inc  r0
       bl   @get_sprite_pattern
       movb r1,*r4+
*      Update background color map
       mov  @wally_y,r0                ; Get y and x
       andi r0,7
       mov  r0,@wally_shift_value      ; x shift
       mov  @wally_y,r1
       swpb r1
       andi r1,7
       mov  r1,@wally_char_aligned     ; y shift
*      TODO: copy attributes behind Wally to map?
       .endproc
*// wally_draw

*********************************************************************
*
* Room draw
*
room_draw:
       .proc
       mov  @wally_room_no,r4          ; Get room number.
       sla  r4,1                       ; Work out address of room pointer.
       mov  @room_data(r4),r4          ; Get address to room description data.
       movb *r4,r0
       cb   r0,@byte_f5                ; Get first byte and test for drawing of walls etc.
       jne  room_draw_1
       bl   @draw_ceiling_wall_floor
       inc  r4
*      Draw furniture
room_draw_1:
       movb *r4+,r0
       cb   r0,@byte_ff
       jeq  room_draw_5                ; End marker
       cb   r0,@byte_f4
       jne  room_draw_2
       seto @tile_flip_vertical             ; Draw upside down
       jmp  room_draw_1
room_draw_2:
       cb   r0,@byte_f3
       jne  room_draw_3
       clr  @tile_flip_vertical             ; Draw normal
       jmp  room_draw_1
room_draw_3:
       cb   r0,@byte_de
       jne  room_draw_4
       movb *r4+,r1                    ; Get address of action flag.
       movb *r4+,@r1lb
       movb *r1,r0                     ; Get action flag
       jeq  room_draw_5                ; If not set then handle action,
       jmp  room_draw_1                ; else continue onto next byte.
room_draw_4:
       swpb r0
       movb *r4+,r0                    ; y position (x in MSB)
       clr  r1
       movb *r4+,@r1lb                 ; Get index of furniture item.
       sla  r1,1
       mov  @furniture_table(r1),r1    ; Workout address of item string.
       bl   @furniture_draw
       jmp  room_draw_1
*      Draw object
room_draw_5:
       mov  @wally_room_no,r3
       sla  r3,1                       ; x2
       a    @wally_room_no,r3          ; x3
       ai   r3,room_obj_slots
       clr  r0
       movb *r3+,@r0lb
       mov  r0,@bitmap_x
       movb *r3+,@r0lb
       ai   r0,>10
       mov  r0,@bitmap_y
       movb *r3,@r0lb
       ai   r0,>50
       bl   @bitmap_16_draw
       .endproc
*// room_draw

*********************************************************************
*
* Draw furniture
*
* Input:
* r0 MSB: y position
* r0 LSB: x position
* r1: Address of furniture item string
*
furniture_draw:
       .proc
       mov  r1,r5                      ; Save address
       mov  r0,r6                      ; Save position
furniture_draw_6:
       movb *r5+,r0                    ; Get next byte in string.
       jgt  furniture_draw_4           ; Test for normal tile.
       jeq  furniture_draw_4
       cb   r0,@byte_ff                ; Test for END OF STRING value.
       jeq  furniture_draw_5
       cb   r0,@byte_fe                ; Test for code.
       jne  furniture_draw_0
       movb *r5+,r0                    ; Get colour.
       bl   @ti_color                  ; Convert to TI color
       mov  r1,r7                      ; Save color
       jmp  furniture_draw_6
furniture_draw_0:
       cb   r0,@byte_fc                ; Test for code.
       jne  furniture_draw_1
       ab   *r5+,@r6lb                 ; Px += Sx
       ab   *r5+,r6                    ; Py += Sy
       jmp  furniture_draw_6
furniture_draw_1:
       cb   r0,@byte_fb                ; Test for code.
       jne  furniture_draw_2
       movb *r5+,@r0lb                 ; Get next two bytes holding new tile start address.
       movb *r5+,r0
       ci   r0,>c1a0
       jl  !
       ai   r0,bmp_tiles->c1a0         ; Adjust address
       jmp  !!
!      ai   r0,tile_ceiling->8c4d      ; Adjust address for ceiling/roof/floor tiles
!      mov  r0,@tile_start_ptr         ; Store for tile_draw to use
       jmp  furniture_draw_6
furniture_draw_2:
       clr  r8
       movb *r5+,@r8lb                 ; Get number of times to draw.
       movb *r5+,r9                    ; Get tile(n) to draw.
furniture_draw_3:
       mov  r9,r0                      ; Tile number
       mov  r6,r1                      ; Position
       mov  r7,r2                      ; Color
       bl   @tile_draw                 ; Draw tile.
       inc  r6                         ; Px++
       dec  r8
       jne  furniture_draw_3
       jmp  furniture_draw_6
furniture_draw_4:
       mov  r6,r1                      ; Position
       mov  r7,r2                      ; Color
       bl   @tile_draw
       inc  r6                         ; Px++
       jmp  furniture_draw_6
furniture_draw_5:
       .endproc
*// furniture_draw

*********************************************************************
*
* Draw ceiling, wall and floor
*
draw_ceiling_wall_floor:
       .proc
       li   r0,tile_ceiling
       mov  r0,@tile_start_ptr
*      Ceiling
       li   r2,attr_43
       li   r6,>0500
       li   r8,>20
draw_ceiling_wall_floor_1:
       clr  r0
       mov  r6,r1
       bl   @tile_draw
       inc  r6
       dec  r8
       jne  draw_ceiling_wall_floor_1
*      Floor
       li   r2,attr_45
       li   r6,>1700
       li   r8,>20
draw_ceiling_wall_floor_2:
       li   r0,>0100
       mov  r6,r1
       bl   @tile_draw
       inc  r6
       dec  r8
       jne  draw_ceiling_wall_floor_2
*      Left wall
       li   r2,attr_42
       li   r6,>0600
       li   r8,>11
draw_ceiling_wall_floor_3:
       li   r0,>0200
       mov  r6,r1
       bl   @tile_draw
       ab   @byte_01,r6
       dec  r8
       jne  draw_ceiling_wall_floor_3
*      Right wall
       li   r6,>061f
       li   r8,>11
draw_ceiling_wall_floor_4:
       li   r0,>0200
       mov  r6,r1
       bl   @tile_draw
       ab   @byte_01,r6
       dec  r8
       jne  draw_ceiling_wall_floor_4
       .endproc
*// draw_ceiling_wall_floor

*********************************************************************
*
* Draw full milk glass
*
milk_draw_full:
       .proc
       li   r0,13*8                    ; Destination
       li   r1,bmp_milk_full
       li   r2,4                       ; 4 rows
milk_draw_full_1:
       bl   @vwad
       li   r3,3                       ; 3 columns
milk_draw_full_2:
       li   r4,8                       ; 8 lines
milk_draw_full_3:
       movb *r1+,*r15
       inct r1
       dec  r4
       jne  milk_draw_full_3
       ai   r1,-23
       dec  r3
       jne  milk_draw_full_2
       ai   r0,256
       ai   r1,21
       dec  r2
       jne  milk_draw_full_1
       .endproc
*// milk_draw_full

*********************************************************************
*
* Draw life
*
* Input:
* r0: life number 0-
*
life_draw_blit:
       .proc
       dec  r0
       sla  r0,4                       ; x16
       mov  r0,@bitmap_x
       li   r0,16
       mov  r0,@bitmap_y
       li   r0,>4c                     ; Index for Life Bitmap
       bl   @bitmap_16_draw
       .endproc
*// life_draw_blit

*********************************************************************
*
* Draw tile
*
* Input:
* r0 MSB: Tile number
* r1 MSB: y position
* r1 LSB: x position
* r2 MSB: color
* Modifies r0,r1,r3
*
tile_draw:
       .proc
*      Update attribute table
       mov  r1,r3
       sla  r3,3
       movb r1,r3
       srl  r3,3
       movb r2,@attr_table(r3)
*      Bitmap screen position
       mov  r1,r3                      ; x and y positions
       andi r3,>001f                   ; x position
       sla  r3,3                       ; x8
       andi r1,>1f00                   ; y position
       abs  @tile_flip_vertical
       jeq  !
       neg  r1                         ; Invert y
       ai   r1,>1C00
!      movb r1,r3
       clr  r1
       movb r0,@r1lb                   ; Tile number
       sla  r1,3                       ; x8
       a    @tile_start_ptr,r1         ; Add base address
*      Draw color
       mov  r3,r0
       ai   r0,colrtb
       bl   @vwad
       movb r2,*r15
       movb r2,*r15
       movb r2,*r15
       movb r2,*r15
       movb r2,*r15
       movb r2,*r15
       movb r2,*r15
       movb r2,*r15
*      Draw tile
       abs  @tile_flip_vertical
       jne  tile_draw_1
*      Draw normal tile
       mov  r3,r0
       bl   @vwad
       movb *r1+,*r15
       movb *r1+,*r15
       movb *r1+,*r15
       movb *r1+,*r15
       movb *r1+,*r15
       movb *r1+,*r15
       movb *r1+,*r15
       movb *r1+,*r15
       jmp  tile_draw_2
tile_draw_1:
*      Draw upside down tile
       mov  r3,r0
       bl   @vwad
       ai   r1,7
       movb *r1,*r15
       dec  r1
       movb *r1,*r15
       dec  r1
       movb *r1,*r15
       dec  r1
       movb *r1,*r15
       dec  r1
       movb *r1,*r15
       dec  r1
       movb *r1,*r15
       dec  r1
       movb *r1,*r15
       dec  r1
       movb *r1,*r15
       dec  r1
tile_draw_2:
       .endproc
*// tile_draw

*********************************************************************
*
* Draw 16x16 bitmap
*
* Input:
* r0: Index of bitmap to draw
* @bitmap_x: x coordinate
* @bitmap_y: y coordinate
*
bitmap_16_draw:
       .proc
       li   r4,bmp_wally
       sla  r0,5
       a    r0,r4                      ; Source address
       mov  @bitmap_x,r0
       mov  @bitmap_y,r1
       bl   @screen_address            ; Result in r6,r7
       ori  r6,>4000                   ; Setup as write address
*      Setup shifts
       mov  r7,r0                      ; Bit offset
       jeq  bitmap_16_draw_1
       mov  @opcode_srl,r8             ; Right shift by offset
       sla  r0,4
       soc  r0,r8
       mov  @opcode_sla,r9             ; Left shift by (8-offset)
       li   r0,8
       s    r7,r0
       sla  r0,4
       soc  r0,r9
       jmp  bitmap_16_draw_2
bitmap_16_draw_1:
       mov  @opcode_nop,r8             ; No shift
       mov  r8,r9
*      1-8 lines of first character row
bitmap_16_draw_2:
       mov  r6,r0
       andi r0,7
       li   r3,8                       ; Line counter
       s    r0,r3
       bl   @bitmap_16_draw_section
*      Full character row
       ai   r6,>0100                   ; Next character row
       andi r6,>fff8                   ; Align to beginning of row
       li   r3,8
       bl   @bitmap_16_draw_section
*      0-7 lines of last character row
       mov  @bitmap_y,r3
       andi r3,7
       jeq  bitmap_16_draw_3
       ai   r6,>0100                   ; Next character row
       andi r6,>fff8                   ; Align to beginning of row
       bl   @bitmap_16_draw_section
bitmap_16_draw_3:
       .endproc
bitmap_16_draw_section:
       mov  r6,r5
*      First byte
       movb @r5lb,@vdpwa               ; Setup VDP write address
       movb r5,@vdpwa
       mov  r4,r0                      ; Source address
       mov  r3,r2
bitmap_16_draw_section_1:
       mov  *r0+,r1                    ; Get source word
       x    r8                         ; Shift right
       movb r1,*r15                    ; Send MSB to VDP
       dec  r2
       jne  bitmap_16_draw_section_1
*      Second byte
       ai   r5,8
       movb @r5lb,@vdpwa               ; Setup VDP write address
       movb r5,@vdpwa
       mov  r4,r0                      ; Source address
       mov  r3,r2
bitmap_16_draw_section_2:
       mov  *r0+,r1                    ; Get source word
       x    r8                         ; Shift right
       movb @r1lb,*r15                 ; Send LSB to VDP
       dec  r2
       jne  bitmap_16_draw_section_2
*      Third byte
       abs  r7
       jeq  bitmap_16_draw_section_4
       ai   r5,8
       movb @r5lb,@vdpwa               ; Setup VDP write address
       movb r5,@vdpwa
       mov  r4,r0                      ; Source address
       mov  r3,r2
bitmap_16_draw_section_3:
       mov  *r0+,r1                    ; Get source word
       x    r9                         ; Shift left
       movb @r1lb,*r15                 ; Send LSB to VDP
       dec  r2
       jne  bitmap_16_draw_section_3
bitmap_16_draw_section_4:
       mov  r0,r4
       rt
opcode_srl:
       srl  r1,0
opcode_sla:
       sla  r1,0
opcode_nop:
       nop
*// bitmap_16_draw


*********************************************************************
*
* Initialize sprites
*
init_sprites:
       .proc
*      Sprite pattern+bitmap map
       li   r0,sprite_pattern_map
       li   r2,sprite_pattern_map_size+sprite_bitmap_map_size
one_time_init_2:
       seto *r0+
       dect r2
       jne  one_time_init_2
*      Sprite table
       li   r0,sprite_table
       li   r1,>c000
       li   r2,sprite_table_size
one_time_init_3:
       mov  r1,*r0+
       clr  *r0+
       dec  r2
       jne  one_time_init_3
*      Set max sprite
       seto @max_sprite
       .endproc
*// init_sprites

*********************************************************************
*
* Allocate sprite
*
* On return r0 contains the address of the allocated sprite
* or 0 if allocation failed.
*
allocate_sprite:
       .proc
       li   r0,sprite_table
       li   r1,>c000
       li   r2,sprite_table_size
allocate_sprite_1:
       cb   *r0,r1
       jeq  allocate_sprite_2
       ai   r0,4
       dec  r2
       jne  allocate_sprite_1
       clr  r0
       jmp  allocate_sprite_3
allocate_sprite_2:
       movb @byte_00,*r0
       mov  r0,r1
       ai   r1,-sprite_table
       srl  r1,2
       c    r1,@max_sprite
       jlt  allocate_sprite_3
       mov  r1,@max_sprite
allocate_sprite_3:
       .endproc
*// allocate_sprite

*********************************************************************
*
* Deallocate sprite
*
* Input:
* r0: address of the allocated sprite
*
deallocate_sprite:
       .proc
       movb @byte_c0,*r0
       mov  @max_sprite,r0
       sla  r0,2
       ai   r0,sprite_table
deallocate_sprite_1:
       cb   *r0,@byte_c0
       jne  deallocate_sprite_2
       dec  @max_sprite
       ai   r0,-sprite_size
       jgt  deallocate_sprite_1
deallocate_sprite_2:
       .endproc
*// deallocate_sprite

*********************************************************************
*
* Upload sprites to VDP
*
upload_sprites:
       .proc
       li   r0,spratb
       li   r1,sprite_table
       mov  @max_sprite,r2
       jlt  upload_sprites_1
       inc  r2
       sla  r2,2
       bl   @vdpcp
       jmp  upload_sprites_2
upload_sprites_1:
       bl   @vwad
upload_sprites_2:
       movb @byte_d0,*r15
       .endproc
*// upload_sprotes

*********************************************************************
*
* Get sprite pattern no corresponding to the given bitmap no.
* Upload sprite pattern if not already present.
*
* Input:
* r0: Index of bitmap
*
* On return r1 MSB contains the pattern no, or >ff if no room.
* Modifies r0-r3
*
get_sprite_pattern:
       .proc
       mov  r0,r3
       movb @sprite_pattern_map(r3),r1
       cb   r1,@byte_ff
       jne  get_sprite_pattern_5
       li   r0,sprite_bitmap_map
       li   r2,sprite_bitmap_map_size
get_sprite_pattern_1:
       cb   *r0+,r1
       jeq  get_sprite_pattern_2
       dec  r2
       jne  get_sprite_pattern_1
       jmp  get_sprite_pattern_5
get_sprite_pattern_2:
       dec  r0                         ; Backtrack
       movb  @r3lb,*r0                 ; Update sprite_bitmap_map
       ai   r0,-sprite_bitmap_map      ; To index
       mov  r0,r1
       sla  r1,2
       swpb r1                         ; Return value
       movb r1,@sprite_pattern_map(r3) ; Update sprite_pattern_map
       sla  r0,5                       ; x32
       ai   r0,sprptb
       bl   @vwad
       sla  r3,5
       ai   r3,bmp_wally               ; Source
*      Upload column 1
       li   r2,16
get_sprite_pattern_3:
       mov  *r3+,*r15
       dec  r2
       jne get_sprite_pattern_3
*      Upload column 2
       ai   r3,-31
       li   r2,16
get_sprite_pattern_4:
       movb *r3,*r15
       inct r3
       dec  r2
       jne get_sprite_pattern_4
get_sprite_pattern_5:
       .endproc
*// get_sprite_pattern

*********************************************************************
*
* Calculate screen address and bit mask from coordinates
* Based on E/A manual page 336       
*
* Input:
* r0 x value
* r1 y value
*
* On return:
* r6  Set to byte offset
* r7  Set to bit offset
*
screen_address:
       mov  r1,r6                      ; 00000000yyyyyyyy
       sla  r6,5                       ; 000yyyyyyyy00000
       soc  r1,r6                      ; 000yyyyy???yyyyy
       andi r6,>ff07                   ; 000yyyyy00000yyy
       mov  r0,r7                      ; 00000000xxxxxxxx
       andi r7,7                       ; 0000000000000xxx
       a    r0,r6                      ; 000yyyyyxxxxx???
       s    r7,r6                      ; 000yyyyyxxxxxyyy
       rt
*// screen_address

*********************************************************************
*
* Get color attribute at pixel position
*
* Input:
* r0 MSB: y position
* r0 LSB: x position
*
* On return:
* r0 MSB: attribute value
* r1: attribute table address
*
get_attribute:
       mov  r0,r1
       andi r0,>00f8
       srl  r0,3
       andi r1,>f800
       srl  r1,6
       soc  r0,r1
       ai   r1,attr_table
       movb *r1,r0
       rt
*// get_attribute

*********************************************************************
*
* Get TI-99 color from ZX Spectrum color
*
* r0 MSB: Colour-byte FBPPPIII
*  - I - Ink colour (0-7)
*  - P - Paper colour (0-7)
*  - B - Bright (0-No, 1-Yes)
*  - F - Flash  (0-No, 1-Yes)
*
* Modifies r2-r3
* On return r1 MSB contains the TI color FFFFBBBB.
*
ti_color:
       clr  r1
*      Foreground
       mov  r0,r2
       andi r2,>0700                   ; Foreground bits
       mov  r0,r3
       andi r3,>4000                   ; Bright bit
       srl  r3,3
       soc  r3,r2
       swpb r2
       movb @tipal(r2),r1
       sla  r1,4
*      Background
       mov  r0,r2
       andi r2,>3800                   ; Background bits
       srl  r2,3
       soc  r3,r2
       swpb r2
       movb @tipal(r2),r3
       socb r3,r1
*      Flash                           ; Invert
       andi r0,>8000
       jeq  !
       srl  r1,4
       andi r1,>0ff0
       socb @r1lb,r1
!      rt

* Spectrum palette
* 0  Black,    1 D Blue,   2 D Red,     3 D Magenta
* 4  D Green,  5 D Cyan,   6 D Yellow,  7 Grey
* 8  Black,    9 Blue,    10 Red,      11 Magenta
* 12 Green,   13 Cyan,    14 Yellow,   15 White

* TI palette
* 0  Trans,    1 Black,    2 M Green,   3 L Green
* 4  D Blue,   5 L Blue,   6 D Red,     7 Cyan
* 8  M Red,    9 L Red,   10 D Yellow, 11 L Yellow
* 12 D Green, 13 Magenta, 14 Gray,     15 White

tipal  byte 1,4,6,13,12,7,10,14,1,5,8,13,2,7,11,15
* Not used: 3 L Green, 9 L Red
* Not available: D Cyan, D Magenta
*// ti_color

*********************************************************************
*
* Clear whole screen
*
screen_clear:
       .proc
*      Patterns
       li   r0,ptrntb
       li   r1,>0000
       li   r2,>1800
       bl   @vdpwr
*      Colors
       li   r0,colrtb
       li   r1,attr_46
       li   r2,>1800
       bl   @vdpwr
*      Attributes
       li   r0,attr_table
       li   r1,attr_46
       li   r2,>300
screen_clear_1:
       movb r1,*r0+
       dec  r2
       jne  screen_clear_1
       .endproc
*// screen_clear

*********************************************************************
*
* Set full bitmap mode
*
bitmap_mode:
       .proc
       clr  r0
       li   r1,vregs2
       li   r2,8
bitmap_mode_1:
       movb *r1+,@r0lb
       bl   @vwtr                      ; Set register
       ai   r0,>0100
       dec  r2
       jne  bitmap_mode_1
*      Name table
       li   r0,nametb
       bl   @vwad
       clr  r1
       li   r2,>300
bitmap_mode_2:
       movb r1,*r15
       ai   r1,>0100
       dec  r2
       jne  bitmap_mode_2
*      Sprite attributes
       li   r0,spratb
       li   r1,>d000
       bl   @vsbw
*      Return
       .endproc
*      VDP registers
vregs2:
       byte >02                        ; Graphics II mode
       byte >e2                        ; 16K, display on, interrupt enabled
       byte nametb/>400                ; Name table
       byte >ff                        ; Color table
       byte ptrntb/>800+>03            ; Pattern table
       byte spratb/>80                 ; Sprite attribute table
       byte sprptb/>800                ; Sprite pattern table
       byte >01                        ; Backdrop color
*// bitmap_mode

*********************************************************************
*
* VDP Write To Register
*
* R0 MSB: VDP register to write to
* R0 LSB: Value to write
*
vwtr:
       swpb r0
       movb r0,@vdpwa                  ; Send low byte (value) to write to VDP register
       swpb r0
       ori  r0,>8000                   ; Set up a VDP register write operation (10)
       movb r0,@vdpwa                  ; Send high byte (address) of VDP register
       b    *r11
*// vwtr

*********************************************************************
*
* VDP Set Write Address
*
* R0: Write address in VDP RAM
*
* R0 is modified, but can be restored with: ANDI R0,>3FFF
*
vwad:
       swpb r0
       movb r0,@vdpwa                  ; Send low byte of VDP RAM write address
       swpb r0
       ori  r0,>4000                   ; Set read/write bits 14 and 15 to write (01)
       movb r0,@vdpwa                  ; Send high byte of VDP RAM write address
       b    *r11
*// vwad

*********************************************************************
*
* VDP Single Byte Read
*
* R0   Read address in VDP RAM
* R1   MSB of R1 set to byte from VDP RAM
*
vsbr:
       swpb r0
       movb r0,@vdpwa                  ; Send low byte of VDP RAM write address
       swpb r0
       movb r0,@vdpwa                  ; Send high byte of VDP RAM write address
       movb @vdprd,r1                  ; Read byte from VDP RAM
       b    *r11
*// vsbr

*********************************************************************
*
* VDP Single Byte Write
*
* R0: Write address in VDP RAM
* R1: MSB of R1 sent to VDP RAM
*
* R0 is modified, but can be restored with: ANDI R0,>3FFF
*
vsbw:
       swpb r0
       movb r0,@vdpwa                  ; Send low byte of VDP RAM write address
       swpb r0
       ori  r0,>4000                   ; Set read/write bits 14 and 15 to write (01)
       movb r0,@vdpwa                  ; Send high byte of VDP RAM write address
       movb r1,*15                     ; Write byte to VDP RAM
       b    *r11
*// vsbw

*********************************************************************
*
* VDP Multiple Byte Read
*
* R0: Starting read address in VDP RAM
* R1: Starting write address in CPU RAM
* R2: Number of bytes to read from VDP RAM
*
* Modifies R0-R2
*
vmbr:
       swpb r0
       movb r0,@vdpwa                  ; Send low byte of VDP RAM write address
       swpb r0
       movb r0,@vdpwa                  ; Send high byte of VDP RAM write address
vmbr0:
       li   r0,vdprd
vmbr1:
       movb *r0,*r1+                   ; Read byte from VDP RAM
       dec  r2                         ; Byte counter
       jne  vmbr1                      ; Check if finished
       b    *r11
*// vmbr

*********************************************************************
*
* Fast CPU to VDP copy, replaces VMBW
*
* R0: Destination address
* R1: Source address
* R2: Number of bytes to copy
*
* Modifies r0-r3
*
vdpcp:
       swpb r0
       movb r0,@vdpwa                  ; Send low byte of VDP RAM write address
       swpb r0
       ori  r0,>4000                   ; Set the two MSbits to 01 for write
       movb r0,@vdpwa                  ; Send high byte of VDP RAM write address
vdpcp0:
       mov  r2,r3
       srl  r3,3                       ; Number of groups of 8
       jeq  vdpcp2
vdpcp1:
       movb *r1+,*r15
       movb *r1+,*r15
       movb *r1+,*r15
       movb *r1+,*r15
       movb *r1+,*r15
       movb *r1+,*r15
       movb *r1+,*r15
       movb *r1+,*r15
       dec  r3
       jne  vdpcp1
       andi r2,>0007                   ; Isolate number of remaining bytes
       jeq  vdpcp3
vdpcp2:
       movb *r1+,*r15
       dec  r2
       jne  vdpcp2
vdpcp3:
       rt
*// vdpcp

*********************************************************************
*
* Fast CPU to VDP write, replaces VSMW
*
* R0: Destination address
* R1: Byte to write in MSB
* R2: Number of bytes to copy
*
* Modifies r0-r3
*
vdpwr:
       swpb r0
       movb r0,@vdpwa                  ; Send low byte of VDP RAM write address
       swpb r0
       ori  r0,>4000                   ; Set the two MSbits to 01 for write
       movb r0,@vdpwa                  ; Send high byte of VDP RAM write address
       mov  r2,r3
       srl  r3,3                       ; Number of groups of 8
       jeq  vdpwr2
vdpwr1:
       movb r1,*r15
       movb r1,*r15
       movb r1,*r15
       movb r1,*r15
       movb r1,*r15
       movb r1,*r15
       movb r1,*r15
       movb r1,*r15
       dec  r3
       jne  vdpwr1
       andi r2,>0007                   ; Isolate number of remaining bytes
       jeq  vdpwr3
vdpwr2:
       movb r1, *r15
       dec  r2
       jne  vdpwr2
vdpwr3:
       rt
*// vdpwr

*********************************************************************
*
* Wait for key press
*
wait_key:
       .proc
wait_key_1:
       bl   @check_quit
       bl   @any_key
       jne  wait_key_2
*       bl   @vsync
*       bl   @play_sound
       jmp  wait_key_1
*      Return
wait_key_2:
       .endproc
*// wait_key

*********************************************************************
*
* Check quit
*
check_quit:
       clr  r1                         ; Test column 0
       li   r12,>0024                  ; Address for column selection
       ldcr r1,3                       ; Select column
       li   r12,>0006                  ; Address to read rows
       stcr r1,8
       andi r1,>1100
       jeq  quit
*      Return
       rt
*      Quit
quit   clr  @>83c4                     ; Reset user ISR address
       blwp @>0000
*// check_quit

*********************************************************************
*
* Check key
*
* r0: Column in MSB: >0000 - >0700, Row in LSB: >0006 - >0014
*
*       Column   0      1    2    3    4    5     6       7
*     Row
*     >0006      =      .    ,    M    N    /    Fire    Fire
*     >0008    Space    L    K    J    H    ;    Left    Left
*     >000A    Enter    O    I    U    Y    P    Right   Right
*     >000C             9    8    7    6    0    Down    Down
*     >000E    Fctn     2    3    4    5    1    Up      Up
*     >0010    Shift    S    D    F    G    A
*     >0012    Ctrl     W    E    R    T    Q
*     >0014             X    C    V    B    Z
*
* On return NEQ means that the key is pressed
*
KEY_FI EQU  >0606
KEY_LF EQU  >0608
KEY_RG EQU  >060A
KEY_DN EQU  >060C
KEY_UP EQU  >060E
KEY_CM EQU  >0206
KEY_FS EQU  >0106
KEY_0  EQU  >050C
KEY_1  EQU  >050E
KEY_2  EQU  >010E
KEY_3  EQU  >020E
KEY_4  EQU  >030E
KEY_5  EQU  >040E
KEY_6  EQU  >040C
KEY_7  EQU  >030C
KEY_8  EQU  >020C
KEY_9  EQU  >010C
KEY_A  EQU  >0510
KEY_B  EQU  >0414
KEY_C  EQU  >0214
KEY_D  EQU  >0210
KEY_E  EQU  >0212
KEY_F  EQU  >0310
KEY_G  EQU  >0410
KEY_H  EQU  >0408
KEY_I  EQU  >020A
KEY_J  EQU  >0308
KEY_K  EQU  >0208
KEY_L  EQU  >0108
KEY_M  EQU  >0306
KEY_N  EQU  >0406
KEY_O  EQU  >010A
KEY_P  EQU  >050A
KEY_Q  EQU  >0512
KEY_R  EQU  >0312
KEY_S  EQU  >0110
KEY_T  EQU  >0412
KEY_U  EQU  >030A
KEY_V  EQU  >0314
KEY_W  EQU  >0112
KEY_X  EQU  >0114
KEY_Y  EQU  >040A
KEY_Z  EQU  >0514
KEY_SP EQU  >0008
KEY_EN EQU  >000A
KEY_FN EQU  >000E
KEY_SH EQU  >0010
KEY_CT EQU  >0012
JOY_FI EQU  >0606
JOY_LT EQU  >0608
JOY_RT EQU  >060A
JOY_DN EQU  >060C
JOY_UP EQU  >060E
*
check_key:
       li   r12,>0024                  ; CRU address of the column decoder
       ldcr r0,3                       ; Select column
       andi r0,>00ff
       mov  r0,r12                     ; Select row
       tb   0                          ; Test key, EQ if not pressed
       rt
*// check_key

*********************************************************************
*
* Resets EQ (neq) if any key is pressed
*
any_key:
*      Check Ctrl
       li   r0,KEY_SH                  ; Shift
       li   r12,>0024                  ; CRU address of the column decoder
       ldcr r0,3                       ; Select column
       andi r0,>00ff
       mov  r0,r12                     ; Select row
       tb   0                          ; Test key, EQ if not pressed
       jeq  any_key_0
       c    r0,r0                      ; Set eq
       jmp  any_key_4
*      Check all columns
any_key_0:
       li   r1,>0000                   ; Column
any_key_1:
       li   r12,>0024                  ; CRU address of the column decoder
       mov  r1,r0
       swpb r0
       ldcr r0,3                       ; Select column
       li   r12,0006                   ; Select row
       stcr r0,8
       seto r2
       cb   r0,r2                      ; If any bit is reset a key is pressed
       jne  any_key_2
       inc  r1
       ci   r1,8
       jne  any_key_1
       jmp  any_key_4                  ; eq ok
any_key_2:
       ci   r1,6
       jne  any_key_3                  ; neq ok
*       inc  @user_input_device         ; Still neq
       jmp  any_key_4
any_key_3:
*       clr  @user_input_device         ; Sets eq
       seto r0                         ; Reset eq
       jmp  any_key_4
any_key_4:
       rt
*// any_key

*********************************************************************
*
* Random number generator
*
rand:
       li   r0,28643                   ; A prime number to multiply by
       mpy  @rand_no,r0
       ai   r0,31873                   ; Add a prime number
       src  r0,7                       ; Shift to break odd/even pattern
       mov  r0,@rand_no
       b    *r11
*// rand

*********************************************************************
*
* Data
*
byte_ff:
       byte >ff
byte_fe:
       byte >fe
byte_fc:
       byte >fc
byte_fb:
       byte >fb
byte_fa:
       byte >fa
byte_f5:
       byte >f5
byte_f4:
       byte >f4
byte_f3:
       byte >f3
byte_e9:
       byte >e9
byte_de:
       byte >de
byte_d0:
       byte >d0
byte_c0:
       byte >c0
byte_bf:
       byte >bf
byte_b0:
       byte >b0
byte_aa:
       byte >aa
byte_20:
       byte >20
byte_1c:
       byte >1c
byte_1a:
       byte >1a
byte_10:
       byte >10
byte_0d:
       byte >0d
byte_0b:
       byte >0b
byte_0c:
       byte >0c
byte_08:
       byte >08
byte_07:
       byte >07
byte_04:
       byte >04
byte_02:
       byte >02
byte_01:
       byte >01
byte_00:
       byte >00
byte_attr_40:                          ; Black
       byte attr_40/256
byte_attr_41:                          ; Blue
       byte attr_41/256
byte_attr_42:                          ; Red
       byte attr_42/256
byte_attr_43:                          ; Magenta
       byte attr_43/256
byte_attr_44:                          ; Green
       byte attr_44/256
byte_attr_45:                          ; Cyan
       byte attr_45/256
byte_attr_46:                          ; Yellow
       byte attr_46/256
byte_attr_47:                          ; White
       byte attr_47/256

       even

sprite_table:
       bss  sprite_table_size*sprite_size

sprite_pattern_map:
* One entry for each bitmap.
* Value is the VDP pattern no, or >ff if pattern not uploaded.
       bss  sprite_pattern_map_size

sprite_bitmap_map:
* One entry for each of the 64 VDP pattern slots.
* Value is the bitmap no, or >ff if unoccupied.
       bss  sprite_bitmap_map_size

       copy "room-event-handlers.a99"
       copy "room-logic.a99"
       copy "room-object-slots.a99"
       copy "furniture.a99"
       copy "scoreboard-item.a99"
       copy "bmp-tiles.a99"
       copy "object-flags.a99"
       copy "food-table.a99"
       copy "object-found-table.a99"

attr_table:
       bss  >300

       aorg >2000

       copy "bmp-milk.a99"
       copy "bmp-wally.a99"
       copy "bmp-objects.a99"
       copy "object-text.a99"
       copy "room-data.a99"

       end  main
